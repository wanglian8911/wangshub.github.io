{"meta":{"title":"神奇的战士","subtitle":"Do The Right Thing.","description":"这个是描述","author":"神奇的战士","url":"http://wangshub.github.io"},"pages":[{"title":"about","date":"2018-07-08T02:36:19.000Z","updated":"2018-07-08T02:36:19.000Z","comments":true,"path":"about/index.html","permalink":"http://wangshub.github.io/about/index.html","excerpt":"","text":"介绍 大家好，我是神奇的战士，一个业余程序员，目前在深圳创业中，写代码和分享代码是\b我的生活乐趣之一。 时间 地点 \b职责 2012 - 2016 哈尔滨工业大学 本科 2016 - 2018 哈尔滨工业大学 硕士 2018 - 至今 哈尔滨工业大学 博士在读 2015 - 至今 乐聚(深圳)机器人技术有限公司 技术总监&amp;合伙人 常用工具 语言：Python、JavaScript、C/C++、Matlab 工具：Emacs、Pycharm、MacOS、Linux、Git、Docker 我的开源项目 wechat_jump_game Douyin-Bot cerebro-codelf 一些书单 《黑客与画家》 《明朝那些事儿》 《用系统来工作》 《搞定 GTD》 《Python3 程序开发指南》 《Reinforce Learning》 《Eloquent JavaScript》 《算法导论》 《人月神话》 联系方式 欢迎一起交流，迸发不一样的火花。 知乎 Github 邮箱：easternslope@yeah.net 微信公众号【舒林笑笑生】：thinkhardtech"},{"title":"分类","date":"2017-11-08T14:11:32.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"categories/index.html","permalink":"http://wangshub.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-11-08T14:19:19.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"custom/index.html","permalink":"http://wangshub.github.io/custom/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-11-08T14:11:50.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"tags/index.html","permalink":"http://wangshub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在roboschool中控制Atlas","slug":"在roboschool中控制Atlas","date":"2018-09-20T09:28:18.000Z","updated":"2018-09-20T11:50:18.000Z","comments":true,"path":"2018/09/20/在roboschool中控制Atlas/","link":"","permalink":"http://wangshub.github.io/2018/09/20/在roboschool中控制Atlas/","excerpt":"","text":"利用 Python 在 OpenAI 的 roboschool 中控制 Atlas 机器人 作者：神奇的战士 Blog: http://thinkhard.tech/ 背景介绍 Atlas: Atlas 机器人是一个双足人形机器人，由\b鼎鼎大名的美国波士顿动力公司为主开发，身高 1.75 米，体重 82kg，它的出现将人形机器人的发展带到了更高的高度。目前可以完成行走、跑步和翻跟头等一系列复杂的动作。作为机器人当中的贵族，价格自然不菲 T_T (更何况还买不到…)。所以只能通过仿真软件在里面过下干瘾。 Roboschool: Roboschool 是基于 OpenAI Gym 强化学习仿真包的物理仿真引擎。由于 MuJuCo 不开源且收费，所以 OpenAI 的大佬们将 Roboschool 作为 MuJuCo 的替代品。可以\b在一个场景当中训练多个 Agent 并且完成一挑战任务。 软件环境安装 \bRooboschool Gym 示例代码 在 2017 年 7 月 17 号，Roboschool \b发布了 Version 1.1 版本，其中导入了 Atlat 机器人模型，相关新闻可见 NEWS \b所以在安装好\b环境后，可以从 RoboschoolAtlasForwardWalk_v1_2017jul.py 中找到控制 Atlas 前进走路的源码。 RoboschoolAtlasForwardWalk_v1_2017jul.py 仿真 Python 运行代码，由于在 \bTrain 的时候，没有对机器人上肢运动进行约束和\b优化，只关注了下肢的移动，\b最终训练的结果有点辣眼睛，我们可以看到一段魔性嚣张的步伐 1python3 RoboschoolAtlasForwardWalk_v1_2017jul.py 鼠标左键 ： \b旋转镜头 鼠标右键 ： 镜头平移 按键 F1 : 开/关 慢动作 按键 F2 : 隐藏/显示 \b仿真步数和\b累积 Rewards 按键 F3 : 隐藏/显示 \bAction 和 Observation 在 机器人强化学习之使用 OpenAI Gym 教程与笔记 中介绍过使用导入 Gym 模型和查看 Observation \b和 Action 的相关参数，对于 Atlas 也同样适用： 12345import roboschoolimport gymenv = gym.make(\"RoboschoolAtlasForwardWalk-v1\")print('action_space = ', env.action_space)print('observation_space = ', env.observation_space) 输出 12action_space = Box(30,)observation_space = Box(70,) 从 env.action_space 和 env.observation_space 可知 Action 维度为 30，Observation 维度为 70。 \bAction 可以理解为机器人有 30 个自由度，可以通过 PD 控制器控制关节角度； Observation 为当前环境的观测向量； 至于Atlas 机器人 Action 和 Observation 详细解释，在 \bRoboschool 的 Wiki 中没有相关说明，OpenAI 的开发者建议用户靠猜的方式来确定 :)。 确定方式为 修改 Roboschool 源码，将 gym_atlas.py 重力修改为 0 \b按照排除\b法，控制变量 Action，然后 env.step(action) ，分别记下向量每个元素对应的自由度关节。 代码说明 Roboschool 开发者解释到由于强化学习训练 Atlas \b走路的代码太杂乱了，\b所以暂时没有 Train 的代码，所以求人不如求己，后面得自己撸代码 ~\b 总体思路是获得 weight 矩阵，即最佳 Policy，输入当前观测向量 Observation 获得下一步的 Action 向量来控制 Atlas 行走。 总结 Roboschool 这个项目适合验证一些简单的强化学习任务，对于新引入的模型\b支持得还不太友好。 基本上没有什么成体系的说明文档，\b所以需要靠多阅读 Roboschool \b和 Gym\b 的 Python 源码来使用。","categories":[],"tags":[]},{"title":"机器人强化学习之使用 OpenAI Gym 教程与笔记","slug":"机器人强化学习之使用 OpenAI Gym 教程与笔记","date":"2018-07-27T02:34:40.000Z","updated":"2018-07-27T02:44:13.000Z","comments":true,"path":"2018/07/27/机器人强化学习之使用 OpenAI Gym 教程与笔记/","link":"","permalink":"http://wangshub.github.io/2018/07/27/机器人强化学习之使用 OpenAI Gym 教程与笔记/","excerpt":"","text":"机器人强化学习之使用 OpenAI Gym 教程与笔记 除了试图直接去建立一个可以模拟成人大脑的程序之外， 为什么不试图建立一个可以模拟小孩大脑的程序呢?如果它接 受适当的教育，就会获得成人的大脑。 — 阿兰·图灵 介绍 强化学习 (Reinforcement learning) 是机器学习的一个子领域用于制定决策和运动自由度控制。强化学习主要研究在复杂未知的环境中，智体(agent)实现某个目标。强化学习最引人入胜的两个特点是 强化学习非常通用，可以用来解决需要作出一些列决策的所有问题：例如，训练机器人跑步和弹跳，制定商品价格和库存管理，玩 Atari 游戏和棋盘游戏等等。 强化学习已经可以在许多复杂的环境中取得较好的实验结果：例如 Deep RL 的 Alpha Go等 Gym 是一个研究和开发强化学习相关算法的仿真平台。 无需智体先验知识； 兼容常见的数值运算库如 TensorFlow、Theano 等 Gym 的一个最小例子 CartPole-v0 123456import gymenv = gym.make('CartPole-v0')env.reset()for _ in range(1000): env.render() env.step(env.action_space.sample()) # take a random action 运行效果 至此，第一个 Hello world 就算正式地跑起来了！ 观测(Observations) 在第一个小栗子中，使用了 env.step() 函数来对每一步进行仿真，在 Gym 中，env.step() 会返回 4 个参数： 观测 Observation (Object)：当前 step 执行后，环境的观测(类型为对象)。例如，从相机获取的像素点，机器人各个关节的角度或棋盘游戏当前的状态等； 奖励 Reward (Float): 执行上一步动作(action)后，智体(agent)获得的奖励(浮点类型)，不同的环境中奖励值变化范围也不相同，但是强化学习的目标就是使得总奖励值最大； 完成 Done (Boolen): 表示是否需要将环境重置 env.reset。大多数情况下，当 Done 为 True 时，就表明当前回合(episode)或者试验(tial)结束。例如当机器人摔倒或者掉出台面，就应当终止当前回合进行重置(reset); 信息 Info (Dict): 针对调试过程的诊断信息。在标准的智体仿真评估当中不会使用到这个 info，具体用到的时候再说。 总结来说，这就是一个强化学习的基本流程，在每个时间点上，智体执行 action，环境返回上一次 action 的观测和奖励，用图表示为 智体与环境交互 在 Gym 仿真中，每一次回合开始，需要先执行 reset() 函数，返回初始观测信息，然后根据标志位 done 的状态，来决定是否进行下一次回合。代码表示为 123456789101112import gymenv = gym.make('CartPole-v0')for i_episode in range(20): observation = env.reset() for t in range(100): env.render() print(observation) action = env.action_space.sample() observation, reward, done, info = env.step(action) if done: print(\"Episode finished after &#123;&#125; timesteps\".format(t+1)) break 仿真截图如下 每次 action 前，将上一次 observation 打印，可以得到打印日志如下 1234567891011[ 0.0349103 1.14771978 -0.03934506 -1.64631971][ 0.0578647 1.34327926 -0.07227145 -1.95099638][ 0.08473028 1.14899616 -0.11129138 -1.68156178][ 0.1077102 0.95532555 -0.14492261 -1.42550525][ 0.12681672 1.15191062 -0.17343272 -1.75974995][ 0.14985493 0.95912509 -0.20862772 -1.52564382]Episode finished after 16 timesteps[ 0.03628829 -0.03189712 -0.01997778 0.02529094][ 0.03565035 -0.22672696 -0.01947196 0.31160431][ 0.03111581 -0.42156616 -0.01323988 0.59808332][ 0.02268449 -0.61650037 -0.00127821 0.8865666 ] 空间（Spaces） 在前面的两个小栗子中，每次执行的动作(action)都是从环境动作空间中随机进行选取的，但是这些动作 (action) 是什么?在 Gym 的仿真环境中，有运动空间 action_space 和观测空间 observation_space 两个指标，程序中被定义为 Space 类型，用于描述有效的运动和观测的格式和范围。下面是一个代码示例 123456import gymenv = gym.make('CartPole-v0')print(env.action_space)#&gt; Discrete(2)print(env.observation_space)#&gt; Box(4,) \u001b[33mWARN: gym.spaces.Box autodetected dtype as &lt;class &#39;numpy.float32&#39;&gt;. Please provide explicit dtype.\u001b[0m Discrete(2) Box(4,) 从程序运行结果来看 action_space 是一个离散 Discrete 类型，从 discrete.py 源码可知，范围是一个 {0,1,...,n-1} 长度为 n 的非负整数集合，在 CartPole-v0 例子中，动作空间表示为 {0,1}。 observation_space 是一个 Box 类型，从 box.py 源码可知，表示一个 n 维的盒子，所以在上一节打印出来的 observation 是一个长度为 4 的数组。数组中的每个元素都具有上下界。 12print(env.observation_space.high)print(env.observation_space.low) [4.8000002e+00 3.4028235e+38 4.1887903e-01 3.4028235e+38] [-4.8000002e+00 -3.4028235e+38 -4.1887903e-01 -3.4028235e+38] 利用运动空间和观测空间的定义和范围，可以将代码写得更加通用。在许多仿真环境中，Box 和 Discrete 是最常见的空间描述，在智体每次执行动作时，都属于这些空间范围内，代码示例为 12345from gym import spacesspace = spaces.Discrete(8) # Set with 8 elements &#123;0, 1, 2, ..., 7&#125;x = space.sample()print(space.contains(x)) print(space.n == 8) True True 在 CartPole-v0 栗子中，运动只能选择左和右，分别用 {0,1} 表示 Gym 中可用的环境 Gym 中从简单到复杂，包含了许多经典的仿真环境和各种数据，其中包括 经典控制和文字游戏：经典的强化学习示例，方便入门； 算法：从例子中学习强化学习的相关算法，在 Gym 的仿真算法中，由易到难方便新手入坑； 雅达利游戏：利用强化学习来玩雅达利的游戏。Gym 中集成了对强化学习有着重要影响的 Arcade Learning Environment，并且方便用户安装； 2D 和 3D 的机器人：这个是我一直很感兴趣的一部分，在 Gym 中控制机器人进行仿真。需要利用第三方的物理引擎如 MuJoCo 。 注册表 Gym 是一个包含各种各样强化学习仿真环境的大集合，并且封装成通用的接口暴露给用户，查看所有环境的代码如下： 12from gym import envsprint(envs.registry.all()) 1dict_values([EnvSpec(Copy-v0), EnvSpec(RepeatCopy-v0), EnvSpec(ReversedAddition-v0), EnvSpec(ReversedAddition3-v0), EnvSpec(DuplicatedInput-v0), EnvSpec(Reverse-v0), EnvSpec(CartPole-v0), EnvSpec(CartPole-v1), EnvSpec(MountainCar-v0), EnvSpec(MountainCarContinuous-v0), EnvSpec(Pendulum-v0), EnvSpec(Acrobot-v1), EnvSpec(LunarLander-v2), EnvSpec(LunarLanderContinuous-v2), EnvSpec(BipedalWalker-v2),... Gym 支持将用户制作的环境写入到注册表中，需要执行 gym.make() 和在启动时注册 register，例如 123456register( id='CartPole-v0', entry_point='gym.envs.classic_control:CartPoleEnv', max_episode_steps=200, reward_threshold=195.0,) 参考链接 https://gym.openai.com/docs/ https://nndl.github.io/ 结语 emmmm … 第一篇强化学习入坑笔记写完，大多是从官方文档看过来的加上了一点点自己的理解，建议文档这东西还是直接看官方的吧，原汁原味 关于作者 神奇的战士 博客：http://thinkhard.tech/ Github: https://github.com/wangshub 微信公众号：舒林笑笑生","categories":[],"tags":[]},{"title":"机器人强化学习笔记（0）","slug":"强化学习笔记","date":"2018-07-03T14:34:36.000Z","updated":"2018-07-08T02:49:12.000Z","comments":true,"path":"2018/07/03/强化学习笔记/","link":"","permalink":"http://wangshub.github.io/2018/07/03/强化学习笔记/","excerpt":"","text":"机器人强化学习笔记（0） 机器学习分类 Machine Learning 强化学习\b问题 RL problem Child walk 监督学习：监督学习由任务驱动，需要创造外部的“导师”，“导师”拥有外部环境的所有先验信息，并教导 Agent 完成特定的任务。但是 Agent \b可以用很多种子任务相结合的方式去完成相同的任务。\b所以创造一个全能的“导师”来训练 Agent \b在实际中几乎是不可能的。 非监督学习：非监督学习是由数据驱动，主要目的是\b找到底层的模式而不是映射关系。例如给用户\b推荐新闻时，非监督学习主要是根据用户先前阅读过的新闻\b来推荐相似的新闻。 强化学习：和上面两种\b方法相比较，强化学习主要是从自身的经验来获取知识，在输入和输出之间存在着映射关系。强化学习\b将奖励函数作为行为的反馈。\b \b解决强化学习问题的框架和算法 强化学习需要平衡 exploration vs exploitation 困境。 \b马尔可夫决策过程(Markov Decision Process) 在强化学习场景下，\b数学模型为马尔可夫决策过程，表示为 状态集合：S 动作集合：A 奖励函数：R 策略：Pi 值：V 从起始状态到结束状态\\(S\\)需要经过动作集合 A。执行每个动作后，都会获得奖励 R，每个动作可能会导致好的或者坏的奖励函数值。策略(Policy)就是\b采取某个系列动作的\b方法，并且会相应的得到奖励函数的值。因此，求解强化学习的目标就是要选取最佳策略(Policy)，在所有可能的状态和时间范围内使得评估函数最大，\b即 最短路径问题(Shortest Path Problem) 求解以最小代价，从地点 A 到地点 F 的最短路径问题，转化为 节点集合 {A, B, C, D, E, F} 从\b\b点到点移动成为动作，{A-&gt;B, C-&gt;D} \b奖励函数为每条边的花费\b 完成 A 点到 F 行走路线成为策略，如 {A-&gt;B-&gt;D-&gt;F}","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"Reinforment Learning","slug":"Reinforment-Learning","permalink":"http://wangshub.github.io/tags/Reinforment-Learning/"}]},{"title":"效率工具网站推荐","slug":"工具网站推荐","date":"2018-06-09T01:58:48.000Z","updated":"2018-07-27T02:34:11.000Z","comments":true,"path":"2018/06/09/工具网站推荐/","link":"","permalink":"http://wangshub.github.io/2018/06/09/工具网站推荐/","excerpt":"","text":"提升生活品质——个人效率工具与资讯网站推荐 这个世界上软件太多，懂你的工具太少； 我是个工具控，经常搜集和\b自己写一些工具和插件来提高生活品质； 本文\b将持续更新和记录我平时工作中重度使用的一些\b效率工具和网站； 工具类 Emacs 地址\b：https://github.com/syl20bnr/spacemacs 推荐指数：⭐️⭐️⭐️⭐️⭐️ 目前用到 Emacs 最多的功能就是 Org mode，用于平时的\b想法收集、思路整理、任务分配。Emacs 功能实在强大，任何能想到的功能基本上都有插件，\b但是刚开始上手会非常不习惯。要想全面掌握，还是要看一些 Lisp。 \bOrg mode \b地址：https://orgmode.org/ 推荐指数：⭐️⭐️⭐️⭐️⭐️ 鉴于 Org mode 实在是太好用了，所以再单独推荐一次。\bOrg mode 是基于节点的结构，利用它可以实现脑图的功能，而且还可以设置每个节点的状态。大多数人(包括我)都是将它作为 GTD 工具来使用，或者可以用来写博客文章。 Brook 地址：https://github.com/txthinking/brook 推荐指数：⭐️⭐️⭐️⭐️ Brook 是一个跨平台的代理工具，作者编译出了各个平台的 Release，在我试过 Brook 协议后，一下子被惊艳到了，代理速度十分惊艳，瞬间我的龟速服务器焕发青春。本来想给 Brook 五星的，但是由于目前它的客户端还不太完善，偶尔存在服务端退出的问题。后续还会持续关注该项目。 Typora 地址：https://typora.io/ 推荐指数：⭐️⭐️⭐️⭐️ 像我这种 Markdown 业余程序员，写的最多很多时候却是文档。Typora 是一个精而美的开源跨平台 Markdown 编辑器，支持 MacOS 、Windows、Linux，\b对 Markdown \b渲染是我见过较为漂亮的，输入的体验也超级棒，同时还可以输出 Pdf 文件。 PicGo 地址：https://github.com/Molunerfinn/PicGo 推荐指数：⭐️⭐️⭐️⭐️⭐️ 一个开源免费图床上传工具，PicGo 目前支持了微博图床，七牛图床，腾讯云 COS v4 Cerebro 地址：https://github.com/KELiON/cerebro 推荐指数：⭐️⭐️⭐️⭐️ 一个开源免费\b的对话式快速启动工具，支持 MacOs、Windows、Linux。目前我在 MacOs 下面切换窗口启动软件都离不开这个工具，还为 Cerebro 写了很多插件。当然类似的工具还有 Alfred 和 Wox 等，但是一个能自己\b随心所欲修改的软件才是好软件，对吧？ \bShareMouse 地址：http://www.keyboard-and-mouse-sharing.com/ \b推荐指数：⭐️⭐️⭐️⭐️ 如果\b你需要在不同系统和电脑之间共享同一个键盘鼠标的话，ShareMouse \b可能就是完美地解决方案，但是需要收费。相对于 Synergy，可以在\b不同窗口之间拖拽和复制文件，美中不足\b的是\b需要收费不开源。 Fish Shell 地址：https://fishshell.com/ 推荐指数：⭐️⭐️⭐️⭐️ 相较于 Zsh Shell，我认为 Fish \b在配置上面更人性化一些，但是有一个槽点就是对 Bash 的指令不完全兼容。推荐使用 Oh-my-fish 和 Fisherman 来进行 Fish 的插件管理。推荐 主题 Agnoster + 配色 Dracula，\b好看到没朋友。 资讯网站 Github 每日 Trending 地址: https://github.com/trending 推荐指数：⭐️⭐️⭐️⭐️⭐️ 每天必须要浏览一遍，能上 Github Trending 的项目\b，必定存在着\b创意和骚操作（有幸上过两次月榜）。 Hacker News 地址：https://news.ycombinator.com/ 推荐指数：⭐️⭐️⭐️⭐️⭐️ 在 Hacker News 热榜上面的新闻，绝对算得上技术界的大新闻，强烈值得每日浏览(需要梯子)。 总结 \b工具或者软件，适合自己才是最好的。\b单纯的夸耀某某语言或者 IDE 是最好的，实在没有太大的必要。 一些技术新闻资讯，还是建议多看英文的\b原文链接，很多中文的营销号只是粗略的翻译和转载，在这个过程中，原有的信息可能发生扭曲和丢失，实在像\b被人咀嚼过的甘蔗，没有太多的营养。 最后欢迎关注我的微信公众号：舒林笑笑生","categories":[],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://wangshub.github.io/tags/Tool/"}]},{"title":"Python抖音机器人，论如何在抖音上找到漂亮小姐姐？","slug":"Python抖音机器人，论如何在抖音上找到漂亮小姐姐？","date":"2018-05-28T06:38:32.000Z","updated":"2018-05-28T07:01:22.000Z","comments":true,"path":"2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/","link":"","permalink":"http://wangshub.github.io/2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/","excerpt":"","text":"如何在抖音上找到漂亮小姐姐—-抖音机器人 最近沉迷于抖音无法自拔，常常花好几个小时在抖音漂亮小姐姐身上。 为了高效、直接地找到漂亮小姐姐，我用 Python + ADB 做了一个 Python 抖音机器人 Douyin-Bot。 特性 [x] 自动翻页 [x] 颜值检测 [x] 人脸识别 [x] 自动点赞 [x] 自动关注 [x] 随机防 Ban [ ] 自动回复 原理 打开《抖音短视频》APP，进入主界面 获取手机截图，并对截图进行压缩 (Size &lt; 1MB)； 请求 人脸识别 API； 解析返回的人脸 Json 信息，对人脸检测切割； 当颜值大于门限值 BEAUTY_THRESHOLD时，点赞并关注； 下一页，返回第一步； 使用教程 相关软件工具安装和使用步骤请参考 wechat_jump_game 和 Android 和 iOS 操作步骤 获取源码：git clone https://github.com/wangshub/Douyin-Bot.git 进入源码目录： cd Douyin-Bot 安装依赖： pip install -r requirements.txt 运行程序：python douyin-bot.py 注意 目前暂时只适配了 一加5(1920x1080 分辨率)，如果手机不是该分辨率，请修改 config/ 文件夹下面的配置文件； 脸部截取 LICENSE MIT 欢迎 Star 和 Fork ~ 项目地址:https://github.com/wangshub/Douyin-Bot","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"ADB","slug":"ADB","permalink":"http://wangshub.github.io/tags/ADB/"}]},{"title":"给博客网站加个球(访客统计)","slug":"给博客加个球-访客统计","date":"2018-05-20T09:09:18.000Z","updated":"2018-05-20T09:31:52.000Z","comments":true,"path":"2018/05/20/给博客加个球-访客统计/","link":"","permalink":"http://wangshub.github.io/2018/05/20/给博客加个球-访客统计/","excerpt":"","text":"给博客网站加个球-访客统计脚本 最近无意中发现了 Revolvermaps 这个网站，可以对网站页面上的访客进行统计。 Demo 演示 神奇的战士的博客 主要特征 访客 IP 地点统计； 访客人数\b统计； 页面停留时间统计； 多样式定制； 免费、易使用； \b使用方法 访问 https://www.revolvermaps.com 复制脚本代码 \b插入到博客网站中的 Html； 效果展示 过去 24 小时访客统计 不同地区统计 \b各地区\b访问人数 各个地区的访问时间 最后 Happy 520 Day ~","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://wangshub.github.io/tags/Blog/"}]},{"title":"使用Emacs进行日程管理（GTD）","slug":"使用Emacs进行日程管理（GTD）","date":"2018-05-13T06:19:22.000Z","updated":"2018-05-20T09:06:01.000Z","comments":true,"path":"2018/05/13/使用Emacs进行日程管理（GTD）/","link":"","permalink":"http://wangshub.github.io/2018/05/13/使用Emacs进行日程管理（GTD）/","excerpt":"","text":"使用 Emacs 进行日程管理 (GTD) 什么是 GTD ? Your mind is for having ideas, not holding them. — David Allen GTD (Getting Things Done) 是一个组织和跟进任务或待办事项的系统架构，但是它的目标要高于仅仅是将事情做完，而是要将待办事项以一个更好的方式完成。GTD 的目标是让人 100% 地相信 GTD 的系统来收集任务、想法。这样才能卸下记忆这些想法的思想包袱，专注的完成当下的任务。GTD 将所有的事情罗列下来，然后再进行分类，你就能从一个比较宏观的角度来看待这一堆问题，并且确定下一步的处理方法，将所有悬而未决的事情尽量地处于我们个人的掌握之中。 更多关于 GTD 方法的介绍可以参考 David Allen 的博客和相关书籍。 理论就介绍到这里了，目前市面上有许许多多在各种平台上收费 GTD 任务管理软件、也有许多开源免费的软件，如 Taskwarrior Todo.txt Emacs Org-mode … 今天主要 Show 一下在 Emacs 中使用 Org-mode 来记录、分类、保存、跟进我的想法和任务 主要特点 基于 Spacemacs 功能强大； 操作难度较大，可定制性强； 利用 Git 工具定期自动备份笔记； Emacs 插件安装步骤 项目地址：https://github.com/carlos-wong/org-agenda-carlos 在 Emacs 中进行日程管理 安装并配置好插件后，使用时主要分三步：\b录入、显示、保存。 Todo 录入 绑定输入快捷键：F7 绑定显示快捷键：F6 选择 Todo 类型 输入事项 安排节点 Todo 显示 结语 现在，每天打开 Emacs 的第一件事就是看今天的 Org ,又有做不完的事情了 ~","categories":[],"tags":[{"name":"Emacs","slug":"Emacs","permalink":"http://wangshub.github.io/tags/Emacs/"},{"name":"Lisp","slug":"Lisp","permalink":"http://wangshub.github.io/tags/Lisp/"}]},{"title":"开源跨平台效率软件Cerebro","slug":"跨平台效率软件Cerebro","date":"2018-04-30T12:26:25.000Z","updated":"2018-04-30T13:28:00.000Z","comments":true,"path":"2018/04/30/跨平台效率软件Cerebro/","link":"","permalink":"http://wangshub.github.io/2018/04/30/跨平台效率软件Cerebro/","excerpt":"","text":"开源跨平台效率软件Cerebro 开源跨平台效率软件Cerebro 主要特性 功能展示 \b应用与文件搜索 基于 Electron，什么都能看 易上手的插件开发 \b插件展示 我们写的一些插件 Cerebro-torrent Cerebro-codelf 结语 在 Mac 下面有很多制作精美的第三方软件，其中就有大名鼎鼎的效率神器 Alfred 。但是只能在 Mac 下面才能使用，而且收费不开源。 今天隆重介绍一下另一款大杀器 Cerebro 以及我是如何在平时工作学习中使用它提升效率的。 不同于菜单，Ui 交互的工作方式，\b类似接自然对话的交互方式，这类对话式的操作软件还是有不少项目，但是跨平台、插件开发来说 Cerebro 是比较出色的，毕竟一个能让自己任意修改的软件才是好软件。@carlos-wong 主要特性 \b美好的生活从 Ctrl-Space 开始； App 快速启动； 电脑文件搜索； \b基于 JavaScript, 一定要试试自己写插件； 跨平台 Mac、Windows、Linux； 做你能想到的任何事； 理论上 Alfred 能做的事情，Cerebro 同样能做到，更重要的是 跨平台开源免费！、跨平台开源免费！、跨平台开源免费！ 功能展示 \b应用与文件搜索 基于 Electron，什么都能看 易上手的插件开发 如果你正好是 JavaScript 的爱好者的话，这款\b软件绝对是你的大杀器，Cerebro \b的插件是同类软件中最容易上手开发的。只需要遵从 Cerebro API ，如果你连文档都懒得看的话，\b个人建议直接从插件列表 Awesome-cerebro 选一个改成你想要的样子就行，开源就是这么有魅力！ \b插件展示 密码管理 执行 Shell 命令 shell 搜索 npm 包 \b生成\b二维码 搜索 Emoji 表情 更多插件列表 Awesome-cerebro 我们写的一些插件 Cerebro-torrent 我写的种子搜片儿神器 Cerebro-torrent &gt; 看个片儿还要打开网页慢慢找?！ Cerebro-codelf [@carlos-wong](https://github.com/carlos-wong) 制作快速地变量名搜索神器 Cerebro-codelf &gt; 给变量起名的事情上，为你生命省 3s 结语 如果你生活中存在着一些机械重复的\b劳动的话，比如煮个咖啡、回复相同内容的邮件、\b打开特定的网页等等，完全可以写成 Cerebro 插件提升效率，而节省下来的时间再用来改进工具，形成正循环！ 欢迎入坑 ~","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wangshub.github.io/tags/JavaScript/"},{"name":"Cerebro","slug":"Cerebro","permalink":"http://wangshub.github.io/tags/Cerebro/"}]},{"title":"cerebro-codelf给变量起名的事情上，为你生命省3s","slug":"cerebro-codelf给变量起名的事情上，为你生命省3s","date":"2018-04-30T12:11:27.000Z","updated":"2018-04-30T12:13:47.000Z","comments":true,"path":"2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/","link":"","permalink":"http://wangshub.github.io/2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/","excerpt":"","text":"cerebro-codelf There are only two hard things in Computer Science: cache invalidation and naming things. – Phil Karlton 给变量起名的事情上，为你生命省 3s。 Cerebro 变量名搜索插件，项目灵感来源 codelf。通过 Cerebro 的搜索窗口快速查找变量名。 特性 快速启动、搜索 中英文搜索 自由定制 安装 插件依赖于 Cerebro Ctrl-Space 打开 Cerebro 输入 plugins codelf，点击安装 使用 Cerebro 中，输入 codelf + [待搜索的变量名]； 上下选择变量名，敲回车 Enter 复制到剪切板； LICENSE MIT 项目地址 https://github.com/carlos-wong/cerebro-codelf 欢迎 fork :fork_and_knife: 和 star :star:","categories":[],"tags":[{"name":"JacaScript","slug":"JacaScript","permalink":"http://wangshub.github.io/tags/JacaScript/"},{"name":"Cerebro","slug":"Cerebro","permalink":"http://wangshub.github.io/tags/Cerebro/"}]},{"title":"python插件式爬虫","slug":"python插件式爬虫","date":"2018-04-25T07:51:05.000Z","updated":"2018-04-25T07:53:41.000Z","comments":true,"path":"2018/04/25/python插件式爬虫/","link":"","permalink":"http://wangshub.github.io/2018/04/25/python插件式爬虫/","excerpt":"","text":"Python 插件式的信息爬虫 🐝 一群不辞劳苦采花小蜜蜂 项目代码地址 本项目运行在可以运行在本地或者服务器端，将不同插件程序获取的信息如：每日天气、新闻等，通过 Github Api 上传到仓库进行保存。当然，你还可以你日常机械重复性的劳动在插件中帮你完成，比如煮咖啡、发邮件等等，真是棒极了。 额外收获 ：定期稳定运行在服务器上，还可以每日贡献一次 Github 贡献度 … 点亮你的人生！ 工程说明 12345678├── app│ └── plugins│ └── weather.py├── builtin_plugins├── config│ └── config.json├── main.py└── upload_github.py main.py : 加载 builtin_plugins/ 和 app/ 下的插件； app/plugins/ : 插件程序存放路径； builtin_plugins ： 内置插件路径； upload_github.py : 通过 Github Api 提交一次 Commit； 使用步骤 生成 Github Token 运行代码 1python main.py 插件接口 Json 格式 可以自己补充插件，各个插件的返回值为字典类型，必须满足如下格式 12345678&#123; \"code\": 0, \"type\": \"weather\", \"date\": \"2018-04-23 20:18:03\", \"content\": &#123; \"city\": \"\\u6df1\\u5733\", \"weather\": \"\\u591a\\u4e91\", \"temperature\": \"21 ~ 26\\u2103\", \"humidity\": \"\\u6e7f\\u5ea6\\uff1a63%\", \"wind\": \"\\u98ce\\u5411\\uff1a\\u5317\\u98ce 2\\u7ea7\", \"radiation\": \"\\u7d2b\\u5916\\u7ebf\\uff1a\\u5f31\", \"air\": \"PM: 43\" &#125;&#125; 参数说明 code: 0 成功、-1 失败； type: 例如 [weather, stock, news] 等； date: 当天日期，如 2018-05-01； content: 获取的 Json 格式信息，这部分提交到仓库保存； Todo [x] Python 插件化信息管理，可拓展； [x] 信息保存到 Github 仓库； [ ] 更多插件补充； [ ] Docker一键部署到本地或服务器； [ ] 信息可视化 [ ] Pyeacharts 网页显示 [ ] Gitpage 静态页面每日渲染 [ ] Itchat 微信推送 [ ] 自动登录 [ ] 自动推送 [ ] 信息查询 [ ] 补充插件内容 [ ] 插件思路收集 [ ] 大新闻日常备份 [ ] 商品价格记录插件","categories":[],"tags":[]},{"title":"Python插件式程序结构设计","slug":"Python插件式程序结构设计","date":"2018-04-23T06:27:19.000Z","updated":"2018-04-23T08:23:16.000Z","comments":true,"path":"2018/04/23/Python插件式程序结构设计/","link":"","permalink":"http://wangshub.github.io/2018/04/23/Python插件式程序结构设计/","excerpt":"","text":"Python 插件式程序结构设计 小姐姐，你的插件掉了 本文源码在 github/wangshub 最近有个问题一直困扰着我，我经常会遇到\b对以前的程序或者代码进行功能的\b扩充，但是由于前期没有太多程序架构上的设计，导致功能扩充时冗余代码太多，而且不方便维护( YC 创始人 Paul Graham 其实推荐这种做法，产品快速上线，获取用户反馈进行修改)。 知名的插件式设计的项目有 Emacs Vs-code Atom 为了拓展软件的功能，经常会将软件设计成插件式结构，所以就从我熟悉的 Python 开始了解这部分知识。 通过 Google， 发现了 Pluginbase Python 插件框架，可以快速实现一个 Python 插件式结构，这篇博客作为阅读笔记。 项目文件结构 12345678910├── app1│ └── plugins│ └── secret.py├── app2│ └── plugins│ └── randomstr.py├── builtin_plugins│ ├── lowercase.py│ └── uppercase.py└── example.py 插件管理器 获取当前项目的路径\b 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osfrom functools import partialfrom pluginbase import PluginBase# For easier usage calculate the path relative to here.here = os.path.abspath(os.path.dirname(__file__))# 函数包装，重新定义函数签名，减少调用参数get_path = partial(os.path.join, here)print('here:', here)print('get_path:', get_path)# Setup a plugin base for \"example.modules\" and make sure to load# all the default built-in plugins from the builtin_plugins folder.plugin_base = PluginBase(package='example.plugins', searchpath=[get_path('./builtin_plugins')])class Application(object): \"\"\"Represents a simple example application.\"\"\" def __init__(self, name): # Each application has a name self.name = name # And a dictionary where it stores \"formatters\". These will be # functions provided by plugins which format strings. self.formatters = &#123;&#125; # and a source which loads the plugins from the \"&#123;app_name&#125;/plugins\" # folder. We also pass the application name as identifier. This # is optional but by doing this out plugins have consistent # internal module names which allows pickle to work. self.source = plugin_base.make_plugin_source( searchpath=[get_path('./%s/plugins' % name)], identifier=self.name) # Here we list all the plugins the source knows about, load them # and the use the \"setup\" function provided by the plugin to # initialize the plugin. for plugin_name in self.source.list_plugins(): plugin = self.source.load_plugin(plugin_name) plugin.setup(self) def register_formatter(self, name, formatter): \"\"\"A function a plugin can use to register a formatter.\"\"\" self.formatters[name] = formatter \b实现插件 插件 1 ： App1 12345678910111213import stringdef make_secret(s): chars = list(s) for idx, char in enumerate(chars): if char not in string.punctuation and not char.isspace(): chars[idx] = 'x' return ''.join(chars)def setup(app): app.register_formatter('secret', make_secret) 插件 2 ： App2 1234567891011121314import randomimport stringdef make_random(s): chars = list(s) for idx, char in enumerate(chars): if char not in string.punctuation and not char.isspace(): chars[idx] = random.choice(string.ascii_letters) return ''.join(chars)def setup(app): app.register_formatter('random', make_random) 内置插件 123456def make_lowercase(s): return s.lower()def setup(app): app.register_formatter('lowercase', make_lowercase) \b调用你的插件 1234567def run_demo(app, source): \"\"\"Shows all formatters in demo mode of an application.\"\"\" print('Formatters for %s:' % app.name) print(' input: %s' % source) for name, fmt in sorted(app.formatters.items()): print(' %10s: %s' % (name, fmt(source))) print('') 相关参考\b链接 如何设计插件式结构的程序，兼谈Python语言的动态性 A simple but flexible plugin system for Python. Python Classes PYTHON-进阶-FUNCTOOLS模块小结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"}]},{"title":"Cerebro插件之电影磁力搜索神器","slug":"Cerebro插件之电影磁力搜索神器","date":"2018-03-31T07:34:51.000Z","updated":"2018-03-31T07:36:01.000Z","comments":true,"path":"2018/03/31/Cerebro插件之电影磁力搜索神器/","link":"","permalink":"http://wangshub.github.io/2018/03/31/Cerebro插件之电影磁力搜索神器/","excerpt":"","text":"Cerebro 插件之电影磁力搜索神器 Cerebro plugin to search torrent of movies 什么？看个片儿还要打开网页慢慢找?！ 这周在学 Node.js, 看了 [@carlos-wong](https://github.com/carlos-wong) 推荐的《Eloquent JavaScript》 这本书的前几章，就抑制不住想写点什么练手。Cerebro 是一个跨平台的快速启动工具（同时支持 Windows、MacOs、Linux），并且可以用 Javascript 定制各种自己喜欢的插件。所以做了一个电影磁力搜索器的插件。 支持平台 Windows、Linux、MacOS 截图 使用 在 Cerebro 对话框中输入电影名称，使用键盘上/下按键选择电影，敲击 回车 ,磁力链接就会自动复制到剪贴板。 magnet [电影名称][空格] 安装步骤 Cerebro 内安装插件 ctrl-space 启动 Cerebro 输入 plugins torrent 点击 install 源码安装 确保安装好了 Cerebro Clone 代码到本地，并执行 123git clone https://github.com/wangshub/cerebro-torrent.gitcd cerebro-torrentyarn install 将 cerebro-torrent 文件夹拷贝或者软链接到 Cerebro 的 node_module 文件夹下； 启动 Cerebro，输入 magnets 葫芦娃，然后敲击 空格； 稍等片刻，上下选择，敲击回车就可以将磁力链接复制到剪贴板； 打开迅雷或者其他下载器，尽情享受吧！ 原理说明 解析输入的指令； 利用 async 和 request 库并发爬取网站； 使用 cheerio 解析网页节点； 嵌入一段 html 对爬取结果进行显示； 代码地址 欢迎 star ⭐️ 和 fork 💫 多提 Issue ! wangshub/cerebro-torrent","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wangshub.github.io/tags/JavaScript/"}]},{"title":"如何解决EDAS上传论文时fonts问题","slug":"如何解决EDAS上传论文时fonts问题","date":"2018-02-10T09:29:54.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2018/02/10/如何解决EDAS上传论文时fonts问题/","link":"","permalink":"http://wangshub.github.io/2018/02/10/如何解决EDAS上传论文时fonts问题/","excerpt":"","text":"如何解决 EDAS 上传论文时 PDF fonts 问题 问题描述 今天在上传 IEEE xplore 论文时遇到上传字体出错的问题 1upload failed: One or more fonts are not embedded. See EDAS FAQ 解决办法 检查字体子集 在 EDAS 上传 Latex 输出的 PDF 文档时，需要检查 PDF 文档的中所有的字体是否是都是 已嵌入子集，检查方式是： 用 Acrobat pdf或 Foxit PDF工具打开待检查的 PDF 文件 paper.pdf 打开 文件(file)-&gt;属性(property)-&gt;字体(fonts) 查看所有的字体是否是已嵌入或者已嵌入子集 更改字体 如果出现未嵌入的子集 helvitica helvitica字体未嵌入的原因是论文中使用了Matlab生成的图像，Matlab 默认使用了 Helvetica 字体，Latex 在引用该图片时，也默认使用了 Helvetica 字体，导致生成的 PDF 文件不能将这个字体嵌入。 解决步骤： 如果是引用的图片是pdf格式，需要使用 shell 命令ps2pdf13，将Helvetica 进行转化 1ps2pdf13 -dPDFSETTINGS=/prepress fig_non_embedded.pdf fig_embedded.pdf 如果你需要嵌入 *.esp图片文件到你的 Latex 文章中，还需要将步骤1中的 *.pdf 转成 *.esp 文件 1pdftops -eps -level2 [pdfname] [epsname] 参考链接 https://sites.google.com/site/xyzliwen/resource/embed_font_ieee_pdf_explore http://www.mit.edu/~kimo/blog/matlab_figures.html ​","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"http://wangshub.github.io/tags/latex/"}]},{"title":"python装饰器学习笔记","slug":"python装饰器学习笔记","date":"2018-02-07T06:02:39.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2018/02/07/python装饰器学习笔记/","link":"","permalink":"http://wangshub.github.io/2018/02/07/python装饰器学习笔记/","excerpt":"","text":"python 装饰器学习笔记 概括 装饰器的作用就是为已经存在的对象添加额外的功能 我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样就提高了程序的可重复利用性，并增加了程序的可读性。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"用python对github用户followers分析","slug":"用python对github用户followers分析","date":"2018-01-15T01:40:16.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2018/01/15/用python对github用户followers分析/","link":"","permalink":"http://wangshub.github.io/2018/01/15/用python对github用户followers分析/","excerpt":"","text":"github 用户 followers 分析 如何分析一个github用户的followers？ 周末手痒，用python分析了一下自己 github 的 followers 用户，统计结果如下 问题分析 在github上，一个用户的主页显示如下，主要对如下用户信息进行提取 - 用户名称 - 所在的位置 - 用户仓库、stars、Followers、Following数量 - 去年一年的贡献度 我们需要对上图红框里面的数据进行提取，最直接的方法是使用requests，通过BeautifulSoup对html中的信息进行提取。 一些弯路 最开始没打算用爬虫的方式来获取用户信息，因为github有公开的REST API v3可以对指定用户的信息进行访问，并且已经有打包好的PyGithub方便调用。但是我实验下来有如下问题所以放弃使用REST API v3 1. API请求频率有限制，无法运用多线程快速获取批量的用户信息 2. 不知道是不是小BUG，通过API无法获得用户去年一年的贡献度contributions 工具 python 3 ： 彻底告别我的py2 BeaufulSoup ：从HTML或XML文件中提取数据 Requests ： 请求网页 多进程 ： 为了更快 pyecharts ： 美的令人窒息的绘图工具 操作步骤 获取目标用户如https://github.com/wangshub?page=1&amp;tab=followers的所有followers； 改变page编号，遍历所有用户； 提取用户关键信息，保存成csv文件； 数据清洗，过滤； 利用pyecharts绘图； 进行地点词频统计； 实验结果 截止2018-01-15,我的github账号一共有1214名follower，分析结果如下 用户地点分析 排除掉没有填写地点信息的用户，将中文转化成pinyin后，词云如下 用户基本上都是来自北京、上海、深圳等地 去年一年用户贡献度分析 如果看用户是否活跃，肯定是看contributions啦 可以看出超过一般多的用户，去年的贡献度都在都在 1~50 之间，新的一年要加油啦。其中一年贡献最多的用户是[@dragon-yuan](https://github.com/dragon-yuan), 在2017年有整整 4,197 个贡献度，不多说了，前去关注一波。 用户followers分析 哇，有大牛，别拦着我，我要去点关注了 用户仓库数量分析 通过爬取用户的仓库数量，进行统计如下 可以看到一个有意思的现象，有少数的人仓库数量超过了1000，打开这几位仁兄的github主页，大部分是fork的项目，其中仓库最多的用户有13100个仓库，叫[@ProgrammerAndHacker](https://github.com/ProgrammerAndHacker)，他是这么介绍自己的 1234I follow best programmer and hacker， Do you want to hacked by them? ^_^ Best programmers and hackers are here: ... 用户stars分析 都说点击star是一个好习惯， 不得不说，github上面还是有点赞狂魔的，这位老铁[@chenruibin](https://github.com/chenruibin)一共点击了10100个赞，真是好习惯～ 用户 following 分析 同样是[@ProgrammerAndHacker](https://github.com/ProgrammerAndHacker)这位仁兄，一共follow了19600个用户，严重怀疑是不是机器人。 最后 不搞了，我要去写论文了TAT，要代码的，来这里找https://github.com/wangshub/who_is_following","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"github","slug":"github","permalink":"http://wangshub.github.io/tags/github/"}]},{"title":"教你用Python来玩微信跳一跳","slug":"教你用Python来玩微信跳一跳","date":"2017-12-29T02:02:41.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/29/教你用Python来玩微信跳一跳/","link":"","permalink":"http://wangshub.github.io/2017/12/29/教你用Python来玩微信跳一跳/","excerpt":"","text":"教你用Python来玩微信跳一跳 2017年12月28日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 demo「跳一跳」。 blog 地址 github 地址 知乎专栏 游戏模式 这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。 玩法类似于《flappy bird》 如果能精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃？所以花2个小时写了一个python脚本进行验证 工具介绍 Python 2.7 Android 手机 Adb 驱动 Python Matplot绘图 原理说明 将手机点击到《跳一跳》小程序界面； 用Adb 工具获取当前手机截图，并用adb将截图pull上来 12adb shell screencap -p /sdcard/1.pngadb pull /sdcard/1.png . 用matplot显示截图； 用鼠标点击起始点和目标位置，计算像素距离； 根据像素距离，计算按压时间； 用Adb工具点击屏幕蓄力一跳； 1adb shell input swipe x y x y time 实验结果 TODO 可以对拉上来的图片进行颜色分割，识别小人和目标中心店，这样就不需要手动点击自动弹跳。 事实证明，机器人比人更会玩儿游戏。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"Python蔡英文facebook主页分析_by神奇的战士","slug":"Python蔡英文facebook主页分析-by神奇的战士","date":"2017-12-25T07:14:39.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/","link":"","permalink":"http://wangshub.github.io/2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/","excerpt":"","text":"Python蔡英文facebook主页分析(by神奇的战士) 博客地址：https://wangshub.github.io/ 公众号：舒林笑笑生 拒绝转载 用Facebook Graph API和情绪分析API对蔡英文Facebook主页进行统计分析。 1. 说明 蔡英文2016年5月20日，蔡英文正式就任台湾地区领导人，成为台湾地区首位女性领导人。 最近台湾省地区新闻主要有： &gt; 新闻来源： 人民网 &gt; 坚决惩治电信诈骗犯罪 切实维护两岸同胞利益 &gt; 两岸学者评新党人士被调查事件：民进党当局逆流而动终将自掘坟墓 &gt; 台民众高呼“醒来”，蔡英文不能继续装睡 &gt; … 但是真实的台湾同胞们是如何看待她的执政表现呢？ 2. 实现工具 如果是直接爬取脸书的主页，需要进行模拟登陆，反爬虫，代理，验证等等一系列的操作。幸好脸书开放出了图API，可以在一定的请求限制下对脸书上的数据进行访问。注意在多线程请求API的时候，不应该请求的太快，否则会被系统封禁一段时间(不要问我为什么-_-)。 目前为止使用了如下这些工具： python 2.7 Facebook Graph API 情感分析API python 词云 python 中文jieba分词 python Pandas python 多线程 3. 数据处理 3.1 posts 首先测试脸书Facebook Graph API，对蔡小姐的post进行访问， curl测试脚本 12curl -i -X GET \\ \"https://graph.facebook.com/v2.11/tsaiingwen/posts?access_token=xxxxxxxxxxxxxxxxx\" 返回示例 1234567891011121314151617\"data\": [ &#123; \"created_time\": \"2017-12-24T11:50:06+0000\", \"message\": \"蔡想想🐱祝福大家聖誕快樂🎅 #MerryChristmas\", \"id\": \"46251501064_10154820163381065\" &#125;, ... ...],\"paging\": &#123; \"cursors\": &#123; \"before\": \"xxxxxx\", \"after\": \"xxxxx\" &#125;, \"next\": \"xxxxxxxxxxxxxxxxxxxxxx\" &#125; 可以观察到，脸书的每一个post都对应了一个唯一的id，由于post的数量是在太多，所以一次请求无法完整获取。根据next可以得到下一页的post，直到next为空时，表示所有的post获取完毕。 根据以上原理，我获取了蔡小姐从开通脸书第一天起到今天，发的每一条post。 横坐标：时间 纵坐标：每天发文数量 自 2008-10-22T13:55:20+0000蔡小姐发了第一条post以来，一共发了4120篇状态，基本上在脸书上还是非常活跃的，在2012年最多一天发送了24条状态，成功刷屏。 3.2 comments 与 3.1节类似，每一个post下都会有网友进行评论，那么如何获取所有评论?参考图谱API文档，利用测试脚本 curl测试脚本 12curl -i -X GET \\ \"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxxxxxx\" 返回示例 12345678910111213141516&#123; \"data\": [ &#123; \"created_time\": \"2017-11-13T07:15:25+0000\", \"message\": \"XXXXXXXX\", \"id\": \"10154729068451065_10154729097936065\" &#125;, ... ... \"paging\": &#123; \"cursors\": &#123; \"before\": \"MTQyNQZDZD\", \"after\": \"MTM5MQZDZD\" &#125;, \"next\": \"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxx&amp;pretty=0&amp;limit=25&amp;after=MTM5MQZDZD\" &#125; 每一条评论都对应着唯一的id，next字段是下一页的评论内容。可以通过设置，选择一夜最多显示100条评论。以此逐级获取所有的评论。 横坐标：时间 纵坐标：每条状态对应的评论数量 一共爬取了1830322条网友评论，最多评论数是23630条。其中几次出现了较大值，原因应该是前几次大陆网友自发组织的Facebook远征军去进行友好访问了。具体内容可以接下来对这几次的峰值进行详细分析。 相关新闻： 帝吧“远征”facebook｜一场表情包大战的爱国交流 如何评价李毅吧 2016 年 1 月 20 日「出征」Facebook？ 4. 数据分析 4.1. 蔡英文主页分析 一共获取了蔡小姐的4120状态，对json的message字段进行提取，将所有的状态的文字保存进行词云分析，看哪些词汇出现的频率最高。 首先利用Pandas对状态的结构数据进行保存； 读取Pandas表格，获取所有的状态文字； 利用jieba中文分词库，对所有的文字进行分割； 显示，保存图片； 蔡小姐词云 4.2. 蔡英文评论分析 从蔡小姐的post的所有评论当中，我找出了一条评论最多的状态，共有23630条评论，对应id为46251501064_10154244975341065，读取对应数据文件，利用词云分析可得 看来台湾网友也十分注意安全开车，其实这条post的评论区被台湾网友刷屏了，看来怨气挺重呢，哈哈哈哈，霸屏具体内容是 12345671.政府請正視目前台灣改裝汽機車問題！排氣管及改裝品可以合法製造 合法販賣 合法進口但裝載車上就不合法 這是什麼邏輯 政府要課稅又要開罰單又是什麼想法？排氣管或車上零件是原廠被惡意檢舉驗車那是否能跟監理單位或環保署拿今日上班請假損失？2.環保局 監理站 警察執法單位 專業度嚴重不足 原廠排氣管也開單 叫民眾到監理單位驗車 當做民眾都很有時間？3.請提供可比照國外變更車體，如重機行李箱、遮陽板、避震、制動煞車系統在不影響行車安全的部份合乎法規4.如民眾遭受到檢舉達人惡意檢舉，因此需要請假驗車，若屬於惡意檢舉，政府需要支付民眾請假之當天工資蔡??...您不是希望台灣能跟世界接軌，那請您重視汽機車改裝合法性與可變更性，在不影響行車安全與噪音的&gt; 情況下，請把檢舉改裝還於司法單位執行，才不構成擾民。 既然这条被刷屏了，那就换成最新的一篇post，看看网友又关心啥问题。。。 截止爬取脸书时，最新一条博客是： 12345你有吃過越南生春捲、香蘭娘惹糕或是薑黃飯嗎？它們是來自東南亞各國的美食，現在也是台灣的美食。今天是國際移民日，前幾天，我邀請了幾位新移民的好朋友來到總統府，一起準備午餐。在這場午餐的約會中，他們和我分享來到台灣生活的點點滴滴，也給我很多建議。謝謝你們來到台灣，讓我們的社會更多元、更茁壯。祝大家國際移民日快樂！#留言告訴我你最喜歡的新南向美食#晚餐文&quot;, 蔡小姐问网友喜欢吃啥美食，我们来看看网友是如何回复的 结合最近的新党王炳忠事件，评论中出现了较多绿色恐怖、王炳忠、白色恐怖等高频词汇 5. TODO 可以分析的数据还有很多，就先分析这么多了，接下来，可以对评论进行情感分析，看下网友对蔡小姐的评论是积极还是消极的多一些。不过经过这一年的时间来看，应该是消极多一点。哈哈哈 总结下来，我认为： 台湾社会的认知是处于一个分裂的状态； 不少年轻人还是无脑反对大陆； 真正理性思考人太少； 不少人处于岛内的小确幸当中； 结合最近的新闻来看，猜测台湾的士兵在开战时会不会遇到为了什么而战斗的信仰问题。哈哈，一百分将军太逗啦","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"linux驱动器和分区的备份，使用dd命令示例","slug":"linux驱动器和分区的备份，使用dd命令示例","date":"2017-12-18T12:04:51.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","link":"","permalink":"http://wangshub.github.io/2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","excerpt":"","text":"dd命令是Linux发行版非常简单的备份工具。 “dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 dd 命令是Linux发行版非常简单的备份工具。该“dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 用dd命令，我们可以创建整盘，磁盘驱动器等备份，下面这篇文章将帮助你学习一些有用的“dd”命令。 ## 1：创建现有分区备份 以下命令将整个分区/dev/sdb1备份到/opt/sdb1.img文件。 # dd if=/dev/sdb1 of=/opt/sdb1.img 样本输出 12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 123.319 s, 66.7 MB/s 2：恢复备份到其他分区 上面 /opt/sdb1.img备份文件可以恢复到其他分区（/dev/sdb2），我们可以用以下命令恢复。 # dd if=/opt/sdb1.img of=/dev/sdb2 样本输出 12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 197.688 s, 41.6 MB/s 现在，你可以看到的/dev/sdb2 是/dev/sdb1 的翻版。 ## 3：创建与现有分区副本 我们可以直接从现有的分区副本来分区。以下命令将创建的/dev/sdb1 到 /dev/sdb2 的副本。 # dd if=/dev/sdb1 of=/dev/sdb2 样本输出 12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 221.431 s, 37.1 MB/s 4：创建现有的硬盘克隆 以下命令将复制前446个字节这是MBR从第一个磁盘到第二个磁盘。这将创建第二个磁盘引导。 。 # dd if=/dev/sda of=/dev/sdb bs=446 count=1 1231+0 records in1+0 records out446 bytes (446 B) copied, 0.00174812 s, 255 kB/s 现在确保在/dev/sdb的匹配为/dev/sda的分区。一旦做到这一点，您可以使用复制每个分区： # dd if=/dev/sda1 of=/dev/sdb1 # dd if=/dev/sda2 of=/dev/sdb2 5：备份和恢复的MBR镜像文件 创建使用以下命令MBR的镜像文件的备份。 # dd if=/dev/sda of=/opt/backup-mbr-sda.img bs=512 count=1 示例输出 1231+0 records in1+0 records out512 bytes (512 B) copied, 0.0115243 s, 44.4 kB/s 接下来的步骤是MBR恢复到不同的磁盘，使用下面的命令来做到这一点。 # dd if=/opt/backup-mbr-sda.img of=/dev/sdb bs=446 count=1","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"}]},{"title":"python数字图像处理-图像噪声与去噪算法","slug":"python数字图像处理-图像噪声与去噪算法","date":"2017-12-16T09:19:29.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/16/python数字图像处理-图像噪声与去噪算法/","link":"","permalink":"http://wangshub.github.io/2017/12/16/python数字图像处理-图像噪声与去噪算法/","excerpt":"","text":"python数字图像处理-图像噪声与去噪算法 figure_1.png 图像噪声 椒盐噪声 概述： 椒盐噪声（salt &amp; pepper noise）是数字图像的一个常见噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。椒盐噪声是一种因为信号脉冲强度引起的噪声，产生该噪声的算法也比较简单。 给一副数字图像加上椒盐噪声的步骤如下： 指定信噪比 SNR （其取值范围在[0, 1]之间） 计算总像素数目 SP， 得到要加噪的像素数目 NP = SP * (1-SNR) 随机获取要加噪的每个像素位置P（i, j） 指定像素值为255或者0。 重复3,4两个步骤完成所有像素的NP个像素 输出加噪以后的图像 高斯噪声 概述： 加性高斯白噪声(Additive white Gaussian noise，AWGN)在通信领域中指的是一种功率谱函数是常数(即白噪声), 且幅度服从高斯分布的噪声信号. 这类噪声通常来自感光元件, 且无法避免. 去噪算法 中值滤波 概述： 中值滤波是一种非线性空间滤波器, 它的响应基于图像滤波器包围的图像区域中像素的统计排序, 然后由统计排序结果的值代替中心像素的值. 中值滤波器将其像素邻域内的灰度中值代替代替该像素的值. 中值滤波器的使用非常普遍, 这是因为对于一定类型的随机噪声, 它提供了一种优秀的去噪能力, 比小尺寸的均值滤波器模糊程度明显要低. 中值滤波器对处理脉冲噪声(也称椒盐噪声)非常有效, 因为该噪声是以黑白点叠加在图像上面的. 与中值滤波相似的还有最大值滤波器和最小值滤波器. 均值滤波 概述： 均值滤波器的输出是包含在滤波掩模领域内像素的简单平均值. 均值滤波器最常用的目的就是减噪. 然而, 图像边缘也是由图像灰度尖锐变化带来的特性, 所以均值滤波还是存在不希望的边缘模糊负面效应. 均值滤波还有一个重要应用, 为了对感兴趣的图像得出一个粗略描述而模糊一幅图像. 这样, 那些较小物体的强度与背景揉合在一起了, 较大物体变得像斑点而易于检测.掩模的大小由即将融入背景中的物体尺寸决定. 代码 见https://github.com/wangshub/python-image-process","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://wangshub.github.io/tags/image/"}]},{"title":"python数字图像处理-图像的基本结构和基础知识","slug":"python数字图像处理-图像的基本结构和基础知识","date":"2017-12-16T09:10:39.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/16/python数字图像处理-图像的基本结构和基础知识/","link":"","permalink":"http://wangshub.github.io/2017/12/16/python数字图像处理-图像的基本结构和基础知识/","excerpt":"","text":"数字图像处理-图像的基本结构和基础知识 LenaRGB.bmp 一、python实现BMP图像的读取和显示 BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的重要来源。Windows的图形用户界面（graphical user interfaces）也在它的内建图像子系统GDI中对BMP格式提供了支持。 BMP文件的数据按照从文件头开始的先后顺序分为四个部分： bmp文件头(bmp file header) ：提供文件的格式、大小等信息 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息 调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表 位图数据(bitmap data)：就是图像数据 参考链接 https://zh.wikipedia.org/wiki/BMP 二、python统计图像的直方图 图像直方图（英语：Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。可以借助观察该直方图了解需要如何调整亮度分布。这种直方图中，横坐标的左侧为纯黑、较暗的区域，而右侧为较亮、纯白的区域。因此，一张较暗图片的图像直方图中的数据多集中于左侧和中间部分；而整体明亮、只有少量阴影的图像则相反。 很多数码相机提供图像直方图功能，拍摄者可以通过观察图像直方图了解到当前图像是否过分曝光或者曝光不足。 计算机视觉领域常借助图像直方图来实现图像的二值化 2 统计直方图.png 参考链接 https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE#%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE 三、RGB、YIQ、HSI、XYZ颜色空间 YIQ YIQ色彩空间通常被北美的电视系统所采用，属于NTSC（National Television Standards Committee）系统。这里Y不是指黄色，而是指颜色的明视度（Luminance），即亮度（Brightness）。其实Y就是图像的灰度值（Gray value），而I和Q则是指色调（Chrominance），即描述图像色彩及饱和度的属性。在YIQ系统中，Y分量代表图像的亮度信息，I、Q两个分量则携带颜色信息，I分量代表从橙色到青色的颜色变化，而Q分量则代表从紫色到黄绿色的颜色变化。 NTSC制为了进一步压缩色度带宽，用色差信号I,Q来代替U,V。若采用U,V色差信号，则色度、亮度信号的共频带部分极大，低端不共频带的亮度信号带宽很小，亮、色干扰大。将彩色图像从RGB转换到YIQ色彩空间，可以把彩色图像中的亮度信息与色度信息分开，分别独立进行处理。 RGB和YIQ的对应关系用下面的方程式表示： 123Y=0.299R+0.587G+0.114BI=0.596R-0.274G-0.322BQ=0.211R-0.523G+0.312B 3 YIQ分量.png HSI 色调H（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。 饱和度S（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。 亮度I（Intensity）：对应成像亮度和图像灰度，是颜色的明亮程度。 若将RGB单位立方体沿主对角线进行投影，可得到六边形，这样，原来沿主对角线的灰色都投影到中心白色点，而红色点（1，0，0）则位于右边的角上，绿色点（0，1，0）位于左上角，蓝色点（0，0，1）则位于左下角。 HSI颜色模型的双六棱锥表示，I是强度轴，色调H的角度范围为[0，2π]，其中，纯红色的角度为0，纯绿色的角度为2π/3，纯蓝色的角度为4π/3。饱和度S是颜色空间任一点距I轴的距离。当然，若用圆表示RGB模型的投影，则HSI色度空间为双圆锥3D表示。 注意： 当强度I=0时，色调H、饱和度S无定义；当S=0时，色调H无定义。 HSI模型也可用圆柱来表示，如图9-5所示。若将其展开，并按图9-6进行定义，可得到HSI调色板。 HSI_Formula.jpg 5 HSI分量.png XYZ 国际照明委员会(CIE)在进行了大量正常人视觉测量和统计,1931年建立了“标准色度观察者”， 从而奠定了现代CIE标准色度学的定量基础。由于“标准色度观察者”用来标定光谱色时出现负 刺激值，计算不便，也不易理解，因此1931年CIE在RGB系统基础上，改用三个假想的原色X、Y、 Z建立了一个新的色度系统。将它匹配等能光谱的三刺激值，定名为“CIE1931 标准色度观察者 光谱三刺激值”，简称为“CIE1931标准色度观察者”。这一系统叫做“CIE1931标准色度系统”或称为&quot; 2° 视场XYZ色度系统&quot;。CIEXYZ颜色空间稍加变换就可得到Yxy色彩空间，其中Y取三刺激值中Y的值， 表示亮度，x、y反映颜色的色度特性。定义如下：在色彩管理中，选择与设备无关的颜色空间是 十分重要的，与设备无关的颜色空间由国际照明委员会(CIE)制定，包括CIEXYZ和CIELAB两个标准。 它们包含了人眼所能辨别的全部颜色。而且，CIEYxy测色制的建立给定量的确定颜色创造了条件。 但是，在这一空间中，两种不同颜色之间的距离值并不能正确地反映人们色彩感觉差别的大小， 也就是说在CIEYxy色厦图中，在 不同的位置不同方向上颜色的宽容量是不同的，这就是Yxy颜色空间 的不均匀性。这一缺陷的存在，使得在Yxy及XYZ空间不能直观地评价颜色。 xyz.jpg 6 XYZ分量.png 四、python代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#encoding: utf-8import numpy as npfrom PIL import Imageimport matplotlib.pyplot as pltimport mathdef show_bmp(img): # BMP 的读取与显示 plt.figure(\"LenaRGB.bmp\") plt.title(\"LenaRGB.bmp\") plt.imshow(img) plt.show()def show_hist(img): # 直方图 plt.figure(\"Lena hist\") plt.title('Lena hist figure') arr = img.flatten() n, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor='green', alpha=0.75) plt.show()def show_rgb(img): # 显示RGB图像 plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('R') plt.imshow(img[:, :, 0], cmap='gray') plt.subplot(223) plt.title('G') plt.imshow(img[:, :, 1], cmap='gray') plt.subplot(224) plt.title('B') plt.imshow(img[:, :, 2], cmap='gray') plt.show()def shou_yiq(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) Y = 0.299 * R + 0.587 * G + 0.114 * B I = 0.596 * R - 0.274 * G - 0.322 * B Q = 0.211 * R - 0.523 * G - 0.312 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(223) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(224) plt.title('Q') plt.imshow(Q, cmap='gray') plt.show() # YIQ = def show_xyz(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) X = 0.490 * R + 0.310 * G + 0.200 * B Y = 0.177 * R + 0.813 * G + 0.011 * B Z = 0.000 * R + 0.010 * G + 0.990 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('X') plt.imshow(X, cmap='gray') plt.subplot(223) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(224) plt.title('Z') plt.imshow(Z, cmap='gray') plt.show()def show_hsi(img): rows, cols, dims = img.shape R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) I = (R + G + B) / 3 E = np.mat(np.ones([rows, cols])) minRGB = np.mat(img.min(2)) lv = 3 * E / (R + G + B) S = E - np.multiply(lv, minRGB) # S = np.mat(np.zeros([rows, cols])) # for i in range(rows): # for j in range(cols): # S[i, j] = 1 - 3/(R[i, j] + G[i, j] + B[i, j]) * min([R[i, j], G[i, j], B[i, j]]) H = np.mat(np.zeros([rows, cols])) for i in range(rows): for j in range(cols): up = (R[i, j] - G[i, j] + R[i, j] - B[i, j]) / 2 down = (R[i, j] - G[i, j])**2 + (R[i, j] - B[i, j]) * (G[i, j] - B[i, j])**0.5 H[i, j] = math.acos(up / down) plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(223) plt.title('S') plt.imshow(S, cmap='gray') plt.subplot(224) plt.title('H') plt.imshow(H, cmap='gray') plt.show()def main(): img = np.array(Image.open('/home/sun/Desktop/PycharmProjects/Digital_image_process_lxk/lab1/LenaRGB.bmp')) rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # show_bmp(img) # show_hist(img) # show_rgb(img) # shou_yiq(img) # show_hsi(img) # show_xyz(img)if __name__ == '__main__': main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://wangshub.github.io/tags/image/"}]},{"title":"python：将图片转换成excel文档","slug":"image-to-excel","date":"2017-12-14T13:28:12.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/14/image-to-excel/","link":"","permalink":"http://wangshub.github.io/2017/12/14/image-to-excel/","excerpt":"","text":"python：将图片转换成excel文档 实现步骤 读取图像，获取图像每个像素点的RGB值； 根据每个像素点的RGB值设置excel每个方格的颜色值； 根据像素点的坐标，写入excel文件； 保存退出； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from PIL import Imageimport numpy as npimport timeimport matplotlib.pyplot as pltimport xlsxwriterdef get_xy(row, col): table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' num1 = col / 26 num2 = col % 26 # print num1, num2 if num1 == 0: return table[num2 - 1] + str(row) else: return table[num1-1] + table[num2 - 1] + str(row)def main(): img = np.array(Image.open('whale.jpeg')) # plt.figure(\"whale\") # plt.imshow(img) # plt.show() rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # print img[188, 188, 0] excel = xlsxwriter.Workbook('image_excel.xlsx') cellformat = excel.add_format(&#123;'bg_color': '#123456', 'font_color': '#654321'&#125;) worksheet1 = excel.add_worksheet() data = [] color = [''] * cols cellcolor = \"\" for i in range(rows): for j in range(cols): # print hex(img[i, j, 0]), hex(img[i, j, 1]), hex(img[i, j, 2]) cellcolor = (hex(img[i, j, 0]) + hex(img[i, j, 1]) + hex(img[i, j, 2])).replace('0x', '') # print cellcolor cellformat = excel.add_format(&#123;'bg_color': '#'+cellcolor, 'font_color': '#'+cellcolor&#125;) # cellformat = excel.add_format(&#123;'bg_color': '#C6EFCE', # 'font_color': '#006100'&#125;) worksheet1.conditional_format(get_xy(i, j), &#123;'type': 'cell', 'criteria': '&lt;', 'value': 50, 'format': cellformat&#125;) # data.append(data_row) excel.close() if __name__ == '__main__': main() # print get_xy(133, 27)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"python check hosts update","slug":"python-check-hosts-update","date":"2017-07-20T14:33:15.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/07/20/python-check-hosts-update/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-check-hosts-update/","excerpt":"","text":"用Python检查 hosts 更新 最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者是否有更新。所以这种苦力活就让Python干好了。 hosts地址 hosts_info.py 1hosts_source = [\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\"] 检查hosts是否有更新 check_hosts.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllib2from .hosts_info import *import osimport filecmpdef hosts_download(): if os.path.exists('hosts'): hosts_name = 'hosts_new' else: hosts_name = 'hosts' # todo: overtime detection f = urllib2.urlopen(hosts_source[0]) print \"downloading hosts\" with open(hosts_name, \"wb\") as code: code.write(f.read())def is_hosts_new(): hosts_download() if not os.path.exists('hosts'): print 'oops, hosts not exists' return -1 elif os.path.exists('hosts') and (not os.path.exists('hosts_new')): print 'first run, only one hosts file' return True elif os.path.exists('hosts') and (os.path.exists('hosts_new')): print 'compare hosts &amp; hosts_new' diff_status = filecmp.cmp('hosts', 'hosts_new') if diff_status: print 'same file' os.remove('hosts_new') return False else: print 'diff file' os.remove('hosts') os.rename('hosts_new', \"hosts\") return True else: return -1 主程序调用 main.py 1234567from check_hosts.check_hosts import *diff_status = is_hosts_new()if diff_status: print \"new hosts !\"else: print 'code: ',diff_status","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"VPN","slug":"Python/VPN","permalink":"http://wangshub.github.io/categories/Python/VPN/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"VPN","slug":"VPN","permalink":"http://wangshub.github.io/tags/VPN/"}]},{"title":"python mail sender","slug":"python-mail-sender","date":"2017-07-20T14:22:06.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/07/20/python-mail-sender/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-mail-sender/","excerpt":"","text":"python 发送邮件 配置服务器和邮箱 mail_info.py 123456mail_host = 'smtp.yeah.net'mail_user = 'mail_name'mail_pass = 'mail_password'sender = 'mail_name@yeah.net'receivers = ['target@mail.com'] 发送邮件 mail_trans.py 1234567891011121314151617181920212223from .mail_info import *import smtplibfrom email.mime.text import MIMETextdef mail_text_send(title, text): message = MIMEText(text, 'plain', 'utf-8') message['Subject'] = title message['From'] = sender message['To'] = receivers[0] try: smtpObj = smtplib.SMTP() # connect host smtpObj.connect(mail_host, 25) # login host smtpObj.login(mail_user, mail_pass) # send smtpObj.sendmail(sender, receivers, message.as_string()) # quit smtpObj.quit() return True except smtplib.SMTPException as e: return False 主程序调用 main.py 12from mail_trans import *mail_text_send('title', 'hello world!')","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"},{"name":"Mail","slug":"Python/Code/Mail","permalink":"http://wangshub.github.io/categories/Python/Code/Mail/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"Mail","slug":"Mail","permalink":"http://wangshub.github.io/tags/Mail/"}]},{"title":"使用python备份博客图床图片","slug":"use-python-to-backup-markdown-images","date":"2017-06-05T15:09:29.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/06/05/use-python-to-backup-markdown-images/","link":"","permalink":"http://wangshub.github.io/2017/06/05/use-python-to-backup-markdown-images/","excerpt":"","text":"# 说明 最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误. 所以花了一点时间,用python 正则匹配 markdown中图片链接,然后下载图片保存到本地文件夹img中.这样就不用担心图片失效啦,当我找到稳定的图床,可以随时把这些图片再上传更新,美滋滋~~~ 功能 [x] .md文件自动搜索 [x] 正则匹配图片链接 [x] 爬取图片内容 [x] 保存文本到本地 步骤 读取文件 =&gt; 正则匹配 =&gt; 图片下载 =&gt; 保存本地 python代码 详细见我的github地址: www.github.com/wangshub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# coding=utf-8import sysimport osimport reimport requestsimport urllibimport urllib2def search(path, word): for filename in os.listdir(path): fp = os.path.join(path, filename) if os.path.isfile(fp) and word in filename: print fp download(str(fp)) elif os.path.isdir(fp): search(fp, word)def download(file_path): # filename = \"test\" name = file_path.split(u\"/\") filename = name[-1] f_md = open(file_path) # all text of md file text = f_md.read().decode('utf-8') # regex img_reg = r'\\!&#123;1&#125;\\[(.*?)\\]\\((.*?)\\)' result = re.findall('!\\[(.*)\\]\\((.*)\\)', text) for i in range(len(result)): img_quote = result[i][0] img_url = result[i][1] # download img request = urllib2.Request(img_url) response = urllib2.urlopen(request) img_contents = response.read() # img name spell urlname = img_url.split(u\"/\") img_name = filename + '_' + \\ str(i) + '_' + img_quote + str(urlname[len(urlname) - 1]) print img_name, '~~~', img_url # write to file f_img = open('img/' + img_name, 'wb') f_img.write(img_contents) f_img.close() f_md.close()search(sys.argv[1], '.md') 食用方法 python md_image_bacup.py /path/to/your/file/ 作者 Author : WangSong E-mail : easternslope@yeah.net","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"markdown","slug":"python/markdown","permalink":"http://wangshub.github.io/categories/python/markdown/"},{"name":"code","slug":"python/markdown/code","permalink":"http://wangshub.github.io/categories/python/markdown/code/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"markdown","slug":"markdown","permalink":"http://wangshub.github.io/tags/markdown/"}]},{"title":"从机sshfs访问主机文件系统","slug":"sshfs-mount-net-disk","date":"2017-05-31T13:16:00.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/31/sshfs-mount-net-disk/","link":"","permalink":"http://wangshub.github.io/2017/05/31/sshfs-mount-net-disk/","excerpt":"","text":"# 说明 需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到scp命令 scp -r /主机/文件 从机名@192.168.x.x:从机目录/.利用sshfs可以直接在从机进行编译,省略拷贝步骤. 系统结构框图 Linux 主机 &lt;=====&gt; Linux 从机 操作步骤 主机 sudo apt-get install openssh-server ifconfig -a获取局域网内 IP地址 从机 sudo apt-get install sshfs sshfs -o idmap=user -o reconnect host_name@192.168.20.236:/path/to/your/workspace /path/to/your/workspace 现在可以从从机开心地访问主机文件了 author : Wangsong mail : easternslope@yeah.net","categories":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/categories/linux/"},{"name":"tool","slug":"linux/tool","permalink":"http://wangshub.github.io/categories/linux/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"},{"name":"tool","slug":"tool","permalink":"http://wangshub.github.io/tags/tool/"}]},{"title":"python 数据结构之二叉搜索树","slug":"python-data-structure-BST","date":"2017-05-29T15:06:12.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/29/python-data-structure-BST/","link":"","permalink":"http://wangshub.github.io/2017/05/29/python-data-structure-BST/","excerpt":"","text":"二叉搜索树定义 一颗二叉搜索树是以二叉树来组织的,每个节点除了 Key 还包括 左孩子, 右孩子, 父节点 等信息. BST满足限制条件: 对于任意节点的X,他的 左子树中关键字最大值&lt;=X.key , 右子树关键字最小值&gt;=X.key 这个关系表示如下 二叉 根据上图定义,一个二叉搜索树的例子是 二叉树操作 查询 插入 删除 查询(搜索) 二叉树搜索采用递归的方式来进行查询,根据二叉搜索树的定义: 左子树存储小值, 右子树存储大值,一个完整的二叉搜索示意图如下 可以写成 伪代码 1234567TREE-SEARCH(x, k) if x == NULL or k == x.key return x if k &lt; x.key return TREE-SEARCH(x.left) if k &gt; x.key return TREE-SEARCH(x.right) 转换成python代码 12345678910111213141516171819def _get(self, key, node): if node is None: return None if key &lt; node.key: return self._get(key, node.left) elif key &gt; node.key: return self._get(key, node.right) else: return node.valdef get(self, key): \"\"\" Return the value paired with 'key' Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" return self._get(key, self.root) 插入 插入和删除比查询呢稍微复杂一些,因为该操作会引起二叉搜索树的大小变化,会改变动态集合的结构.插入呢又比删除稍微容易实现.插入分为两部 查询插入节点 改变目标节点附近的数据结构 插入过程示意图如下 相应的伪代码如下, 输入节点 z , z.key = v, z.left = NULL, z.right = NULL. 12345678910111213141516TREE-INSERT(T, x) y = NULL x = T.root # 从根节点开始 while x != NULL y = x # 保存上一节点 if z.key &lt; x.key # 往左 x = x.left else # 往右 x = x.right z.p = y # 父节点 if y == NULL # tree T 为空 T.root = z else if z.key &lt; y.key y.left = z else y.right = z 程序的运行复杂度取决于二叉树的形状 插入的运行时间取决于二叉搜索树的_高度h_,程序的运行时间_O(h)_ ,所以二叉树形状的好坏直接影响算法的运行时间. python代码实现为 123456789101112131415161718192021222324252627def _put(self, key, val, node): # If we hit the end of a branch, create a new node if node is None: return Node(key, val) # Follow left branch if key &lt; node.key: node.left = self._put(key, val, node.left) # Follow right branch elif key &gt; node.key: node.right = self._put(key, val, node.right) # Overwrite value else: node.val = val node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef put(self, key, val): \"\"\" Add a new key-value pair. Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" self.root = self._put(key, val, self.root) 删除 删除总共分为三种情况: 如果删除节点x没有孩子,直接删除即可; 如果删除节点x有1个孩子,用孩子替换该节点位置; 如果删除节点x有2个孩子, 这个情况有些复杂.关键是要找到节点 x的继承者 . 节点z的继承者在节点z的右子树中有最小的关键值.这种情况下的操作分为下面步骤: 输入待删除的节点x 和 二叉搜索树T. 在节点x的右子树开始搜索:往右再往左找到最小值节点H; H右孩子为H的父节点, H的左孩子为X的左孩子; 示意图如下,应该一目了然: ](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![ 根据上面的描述,删除的伪代码可以分为两部分: 为了移动子树, 用一棵子树替换一棵子树,并成为双亲的孩子节点. 123456789TRANSPLANT(T, u, v)if u.p == NULLT.root = velse if u = u.p.leftu.p.left = velse u.p.right = vif v!= NULLv.p = u.p 根据第一步完成二叉搜索树的删除过程: 1234567891011121314TREE-DELETE(T, z)if z.left = NULLTRANSPLANT(T, z, z.right)else if (z.right == NULL)TRANSPLANT(T, z, z.left)elsey = TREE-MINIMUM(z.right)if y.p != zTRANSPLANT(T, y, y.right)y.right = z.righty.right.p = yTRANSPLANT(T, z, y)y.left = z.lefty.left.p = y 用python 实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def _delete(self, key, node): if node is None: return None if key &lt; node.key: node.left = self._delete(key, node.left) elif key &gt; node.key: node.right = self._delete(key, node.right) else: if node.right is None: return node.left elif node.left is None: return node.right else: old_node = node node = self._ceiling_node(key, node.right) node.right = self._delete_min(old_node.right) node.left = old_node.left node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _delete_min(self, node): if node.left is None: return node.right node.left = self._delete_min(node.left) node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _ceiling_node(self, key, node): \"\"\" Returns the node with the smallest key that is greater than or equal to the given value 'key' \"\"\" if node is None: return None if key &lt; node.key: # Ceiling is either in left subtree or is this node attempt_in_left = self._ceiling_node(key, node.left) if attempt_in_left is None: return node else: return attempt_in_left elif key &gt; node.key: # Ceiling must be in right subtree return self._ceiling_node(key, node.right) else: # Keys are equal so ceiling is node with this key return node 参考文献 &lt;&gt; http://algs4.cs.princeton.edu/32bst/","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"code","slug":"python/code","permalink":"http://wangshub.github.io/categories/python/code/"},{"name":"algorithm","slug":"python/code/algorithm","permalink":"http://wangshub.github.io/categories/python/code/algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"}]},{"title":"python的webrtc库实现语音端点检测","slug":"python-vad","date":"2017-05-25T13:47:56.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/25/python-vad/","link":"","permalink":"http://wangshub.github.io/2017/05/25/python-vad/","excerpt":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ ## 引言 语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大. 但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段. 现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: * 语音转文字(ASR/STT) * 语义内容(NLU/NLP) * 文字转语音(TTS) 语音转文字(ASR/STT) 在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: * 麦克风降噪 * 声源定位 * 回声消除 * 唤醒词 * 语音端点检测 * 音频格式压缩","text":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ ## 引言 语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大. 但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段. 现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: * 语音转文字(ASR/STT) * 语义内容(NLU/NLP) * 文字转语音(TTS) 语音转文字(ASR/STT) 在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: * 麦克风降噪 * 声源定位 * 回声消除 * 唤醒词 * 语音端点检测 * 音频格式压缩 python 端点检测 由于实际应用中,单纯依靠能量检测特征检测等方法很难判断人声说话的起始点,所以市面上大多数的语音产品都是使用唤醒词判断语音起始.另外加上声音回路,还可以做语音打断.这样的交互方式可能有些傻,每次必须喊一下 唤醒词 才能继续聊天.这种方式聊多了,个人感觉会嘴巴疼:-O .现在github上有snowboy唤醒词的开源库,大家可以登录snowboy官网训练自己的唤醒词模型. * Kitt-AI : Snowboy * Sensory : Sensory 考虑到用唤醒词嘴巴会累,所以大致调研了一下,python拥有丰富的库,直接import就能食用.这种方式容易受强噪声干扰,适合一个人在家玩玩. * pyaudio: pip install pyaudio 可以从设备节点读取原始音频流数据,音频编码是PCM格式; * webrtcvad: pip install webrtcvad 检测判断一组语音数据是否为空语音; 当检测到持续时间长度 T1 vad检测都有语音活动,可以判定为语音起始; 当检测到持续时间长度 T2 vad检测都没有有语音活动,可以判定为语音结束; 完整程序代码可以从我的github下载 程序很简单,相信看一会儿就明白了 &#39;&#39;&#39; Requirements: + pyaudio - `pip install pyaudio` + py-webrtcvad - `pip install webrtcvad` &#39;&#39;&#39; import webrtcvad import collections import sys import signal import pyaudio from array import array from struct import pack import wave import time FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK_DURATION_MS = 30 # supports 10, 20 and 30 (ms) PADDING_DURATION_MS = 1500 # 1 sec jugement CHUNK_SIZE = int(RATE * CHUNK_DURATION_MS / 1000) # chunk to read CHUNK_BYTES = CHUNK_SIZE * 2 # 16bit = 2 bytes, PCM NUM_PADDING_CHUNKS = int(PADDING_DURATION_MS / CHUNK_DURATION_MS) # NUM_WINDOW_CHUNKS = int(240 / CHUNK_DURATION_MS) NUM_WINDOW_CHUNKS = int(400 / CHUNK_DURATION_MS) # 400 ms/ 30ms ge NUM_WINDOW_CHUNKS_END = NUM_WINDOW_CHUNKS * 2 START_OFFSET = int(NUM_WINDOW_CHUNKS * CHUNK_DURATION_MS * 0.5 * RATE) vad = webrtcvad.Vad(1) pa = pyaudio.PyAudio() stream = pa.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, start=False, # input_device_index=2, frames_per_buffer=CHUNK_SIZE) got_a_sentence = False leave = False def handle_int(sig, chunk): global leave, got_a_sentence leave = True got_a_sentence = True def record_to_file(path, data, sample_width): &quot;Records from the microphone and outputs the resulting data to &#39;path&#39;&quot; # sample_width, data = record() data = pack(&#39;&lt;&#39; + (&#39;h&#39; * len(data)), *data) wf = wave.open(path, &#39;wb&#39;) wf.setnchannels(1) wf.setsampwidth(sample_width) wf.setframerate(RATE) wf.writeframes(data) wf.close() def normalize(snd_data): &quot;Average the volume out&quot; MAXIMUM = 32767 # 16384 times = float(MAXIMUM) / max(abs(i) for i in snd_data) r = array(&#39;h&#39;) for i in snd_data: r.append(int(i * times)) return r signal.signal(signal.SIGINT, handle_int) while not leave: ring_buffer = collections.deque(maxlen=NUM_PADDING_CHUNKS) triggered = False voiced_frames = [] ring_buffer_flags = [0] * NUM_WINDOW_CHUNKS ring_buffer_index = 0 ring_buffer_flags_end = [0] * NUM_WINDOW_CHUNKS_END ring_buffer_index_end = 0 buffer_in = &#39;&#39; # WangS raw_data = array(&#39;h&#39;) index = 0 start_point = 0 StartTime = time.time() print(&quot;* recording: &quot;) stream.start_stream() while not got_a_sentence and not leave: chunk = stream.read(CHUNK_SIZE) # add WangS raw_data.extend(array(&#39;h&#39;, chunk)) index += CHUNK_SIZE TimeUse = time.time() - StartTime active = vad.is_speech(chunk, RATE) sys.stdout.write(&#39;1&#39; if active else &#39;_&#39;) ring_buffer_flags[ring_buffer_index] = 1 if active else 0 ring_buffer_index += 1 ring_buffer_index %= NUM_WINDOW_CHUNKS ring_buffer_flags_end[ring_buffer_index_end] = 1 if active else 0 ring_buffer_index_end += 1 ring_buffer_index_end %= NUM_WINDOW_CHUNKS_END # start point detection if not triggered: ring_buffer.append(chunk) num_voiced = sum(ring_buffer_flags) if num_voiced &gt; 0.8 * NUM_WINDOW_CHUNKS: sys.stdout.write(&#39; Open &#39;) triggered = True start_point = index - CHUNK_SIZE * 20 # start point # voiced_frames.extend(ring_buffer) ring_buffer.clear() # end point detection else: # voiced_frames.append(chunk) ring_buffer.append(chunk) num_unvoiced = NUM_WINDOW_CHUNKS_END - sum(ring_buffer_flags_end) if num_unvoiced &gt; 0.90 * NUM_WINDOW_CHUNKS_END or TimeUse &gt; 10: sys.stdout.write(&#39; Close &#39;) triggered = False got_a_sentence = True sys.stdout.flush() sys.stdout.write(&#39;\\n&#39;) # data = b&#39;&#39;.join(voiced_frames) stream.stop_stream() print(&quot;* done recording&quot;) got_a_sentence = False # write to file raw_data.reverse() for index in range(start_point): raw_data.pop() raw_data.reverse() raw_data = normalize(raw_data) record_to_file(&quot;recording.wav&quot;, raw_data, 2) leave = True stream.close() 程序运行方式sudo python vad.py qrcode_for_gh_3586401957c4_258.jpg Remove","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"}]},{"title":"Atom editor","slug":"Atom-editor","date":"2017-05-25T13:27:42.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/25/Atom-editor/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Atom-editor/","excerpt":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装 我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件 Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置 Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份 经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","text":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装 我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件 Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置 Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份 经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","categories":[{"name":"Tool","slug":"Tool","permalink":"http://wangshub.github.io/categories/Tool/"},{"name":"Linux","slug":"Tool/Linux","permalink":"http://wangshub.github.io/categories/Tool/Linux/"}],"tags":[{"name":"Editor","slug":"Editor","permalink":"http://wangshub.github.io/tags/Editor/"}]},{"title":"Cmake 模板","slug":"Cmake-tutorial","date":"2017-05-24T16:03:34.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/25/Cmake-tutorial/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Cmake-tutorial/","excerpt":"","text":"由于之前的代码Cmake写的比较混乱，库链接的不规范，今天花了一些时间，重写Cmakelist.txt，方便后来的开发。可以根据我的模板开始进行C/C++的项目开发.主要分下面几个方面 &gt; * 更新CMakeList.txt文件 &gt; * 改变头文件位置，索引文件夹 &gt; * 上传新的gitlab CMakeList.txt模板 全局CMakeList.txt文件 123456789101112131415161718192021222324252627# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (aelos1s)# sys dirfind_package (Threads)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)add_subdirectory(lib)# 指定生成目标add_executable(aelos $&#123;DIR_SRCS&#125;)# 添加链接库# 生成链接库target_link_libraries(aelos aeloslib)# 多线程链接库target_link_libraries (aelos $&#123;CMAKE_THREAD_LIBS_INIT&#125;) 头文件库CMakeList.txt文件 123456# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 aeloslib 链接库add_library (aeloslib $&#123;DIR_LIB_SRCS&#125;) 工程目录结构 the file structure is |----main.cpp #主程序 |----lib/ #*.cpp and *.h |----build/ #可执行文件生成文件夹 工程参考模板的github地址 https://github.com/wangshub/cmake","categories":[{"name":"Programming","slug":"Programming","permalink":"http://wangshub.github.io/categories/Programming/"},{"name":"Linux","slug":"Programming/Linux","permalink":"http://wangshub.github.io/categories/Programming/Linux/"},{"name":"c/c++","slug":"Programming/Linux/c-c","permalink":"http://wangshub.github.io/categories/Programming/Linux/c-c/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Linux","slug":"Linux","permalink":"http://wangshub.github.io/tags/Linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-14T13:28:12.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/04/14/hello-world/","link":"","permalink":"http://wangshub.github.io/2017/04/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}