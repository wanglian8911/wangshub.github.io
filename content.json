{"meta":{"title":"神奇的战士","subtitle":"Do The Right Thing.","description":"这个是描述","author":"神奇的战士","url":"http://wangshub.github.io"},"pages":[{"title":"about","date":"2018-06-05T06:17:02.000Z","updated":"2018-06-05T06:17:02.000Z","comments":true,"path":"about/index.html","permalink":"http://wangshub.github.io/about/index.html","excerpt":"","text":"介绍 大家好，我是神奇的战士，一个业余程序员，目前在深圳创业中，写代码和分享代码是\b我的生活乐趣之一。 时间 地点 \b职责 2012 - 2016 哈尔滨工业大学 本科 2016 - 2018 哈尔滨工业大学 硕士 2015 - 至今 乐聚(深圳)机器人技术有限公司 技术总监&amp;合伙人 常用工具 语言：Python、JavaScript、C/C++、Matlab 工具：Emacs、Pycharm、MacOS、Linux、Git、Docker 一些书单 《黑客与画家》 《明朝那些事儿》 《用系统来工作》 《搞定 GTD》 《Python3 程序开发指南》 《Reinforce Learning》 《Eloquent JavaScript》 《算法导论》 联系方式 欢迎一起交流，迸发不一样的火花。 知乎 Github 邮箱：easternslope@yeah.net 微信公众号【舒林笑笑生】：thinkhardtech"},{"title":"分类","date":"2017-11-08T14:11:32.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"categories/index.html","permalink":"http://wangshub.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-11-08T14:19:19.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"custom/index.html","permalink":"http://wangshub.github.io/custom/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-11-08T14:11:50.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"tags/index.html","permalink":"http://wangshub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python抖音机器人，论如何在抖音上找到漂亮小姐姐？","slug":"Python抖音机器人，论如何在抖音上找到漂亮小姐姐？","date":"2018-05-28T06:38:32.000Z","updated":"2018-05-28T07:01:22.000Z","comments":true,"path":"2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/","link":"","permalink":"http://wangshub.github.io/2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/","excerpt":"","text":"如何在抖音上找到漂亮小姐姐—-抖音机器人最近沉迷于抖音无法自拔，常常花好几个小时在抖音漂亮小姐姐身上。 为了高效、直接地找到漂亮小姐姐，我用 Python + ADB 做了一个 Python 抖音机器人 Douyin-Bot。 特性 自动翻页 颜值检测 人脸识别 自动点赞 自动关注 随机防 Ban 自动回复 原理 打开《抖音短视频》APP，进入主界面 获取手机截图，并对截图进行压缩 (Size &lt; 1MB)； 请求 人脸识别 API； 解析返回的人脸 Json 信息，对人脸检测切割； 当颜值大于门限值 BEAUTY_THRESHOLD时，点赞并关注； 下一页，返回第一步； 使用教程 相关软件工具安装和使用步骤请参考 wechat_jump_game 和 Android 和 iOS 操作步骤 获取源码：git clone https://github.com/wangshub/Douyin-Bot.git 进入源码目录： cd Douyin-Bot 安装依赖： pip install -r requirements.txt 运行程序：python douyin-bot.py 注意 目前暂时只适配了 一加5(1920x1080 分辨率)，如果手机不是该分辨率，请修改 config/ 文件夹下面的配置文件； 脸部截取 LICENSEMIT 欢迎 Star 和 Fork ~ 项目地址:https://github.com/wangshub/Douyin-Bot","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"ADB","slug":"ADB","permalink":"http://wangshub.github.io/tags/ADB/"}]},{"title":"给博客网站加个球(访客统计)","slug":"给博客加个球-访客统计","date":"2018-05-20T09:09:18.000Z","updated":"2018-05-20T09:31:52.000Z","comments":true,"path":"2018/05/20/给博客加个球-访客统计/","link":"","permalink":"http://wangshub.github.io/2018/05/20/给博客加个球-访客统计/","excerpt":"","text":"给博客网站加个球-访客统计脚本 最近无意中发现了 Revolvermaps 这个网站，可以对网站页面上的访客进行统计。 Demo 演示神奇的战士的博客 主要特征 访客 IP 地点统计； 访客人数\b统计； 页面停留时间统计； 多样式定制； 免费、易使用； \b使用方法 访问 https://www.revolvermaps.com 复制脚本代码 \b插入到博客网站中的 Html； 效果展示 过去 24 小时访客统计 不同地区统计 \b各地区\b访问人数 各个地区的访问时间 最后 Happy 520 Day ~","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://wangshub.github.io/tags/Blog/"}]},{"title":"使用Emacs进行日程管理（GTD）","slug":"使用Emacs进行日程管理（GTD）","date":"2018-05-13T06:19:22.000Z","updated":"2018-05-20T09:06:01.000Z","comments":true,"path":"2018/05/13/使用Emacs进行日程管理（GTD）/","link":"","permalink":"http://wangshub.github.io/2018/05/13/使用Emacs进行日程管理（GTD）/","excerpt":"","text":"使用 Emacs 进行日程管理 (GTD)什么是 GTD ? Your mind is for having ideas, not holding them. — David Allen GTD (Getting Things Done) 是一个组织和跟进任务或待办事项的系统架构，但是它的目标要高于仅仅是将事情做完，而是要将待办事项以一个更好的方式完成。GTD 的目标是让人 100% 地相信 GTD 的系统来收集任务、想法。这样才能卸下记忆这些想法的思想包袱，专注的完成当下的任务。GTD 将所有的事情罗列下来，然后再进行分类，你就能从一个比较宏观的角度来看待这一堆问题，并且确定下一步的处理方法，将所有悬而未决的事情尽量地处于我们个人的掌握之中。 更多关于 GTD 方法的介绍可以参考 David Allen 的博客和相关书籍。 理论就介绍到这里了，目前市面上有许许多多在各种平台上收费 GTD 任务管理软件、也有许多开源免费的软件，如 Taskwarrior Todo.txt Emacs Org-mode … 今天主要 Show 一下在 Emacs 中使用 Org-mode 来记录、分类、保存、跟进我的想法和任务 主要特点 基于 Spacemacs 功能强大； 操作难度较大，可定制性强； 利用 Git 工具定期自动备份笔记； Emacs 插件安装步骤项目地址：https://github.com/carlos-wong/org-agenda-carlos 在 Emacs 中进行日程管理安装并配置好插件后，使用时主要分三步：\b录入、显示、保存。 Todo 录入绑定输入快捷键：F7绑定显示快捷键：F6 选择 Todo 类型 输入事项 安排节点 Todo 显示 结语现在，每天打开 Emacs 的第一件事就是看今天的 Org ,又有做不完的事情了 ~","categories":[],"tags":[{"name":"Emacs","slug":"Emacs","permalink":"http://wangshub.github.io/tags/Emacs/"},{"name":"Lisp","slug":"Lisp","permalink":"http://wangshub.github.io/tags/Lisp/"}]},{"title":"开源跨平台效率软件Cerebro","slug":"跨平台效率软件Cerebro","date":"2018-04-30T12:26:25.000Z","updated":"2018-04-30T13:28:00.000Z","comments":true,"path":"2018/04/30/跨平台效率软件Cerebro/","link":"","permalink":"http://wangshub.github.io/2018/04/30/跨平台效率软件Cerebro/","excerpt":"","text":"开源跨平台效率软件Cerebro 开源跨平台效率软件Cerebro 主要特性 功能展示 \b应用与文件搜索 基于 Electron，什么都能看 易上手的插件开发 \b插件展示 我们写的一些插件 Cerebro-torrent Cerebro-codelf 结语 在 Mac 下面有很多制作精美的第三方软件，其中就有大名鼎鼎的效率神器 Alfred 。但是只能在 Mac 下面才能使用，而且收费不开源。 今天隆重介绍一下另一款大杀器 Cerebro 以及我是如何在平时工作学习中使用它提升效率的。 不同于菜单，Ui 交互的工作方式，\b类似接自然对话的交互方式，这类对话式的操作软件还是有不少项目，但是跨平台、插件开发来说 Cerebro 是比较出色的，毕竟一个能让自己任意修改的软件才是好软件。@carlos-wong 主要特性 \b美好的生活从 Ctrl-Space 开始； App 快速启动； 电脑文件搜索； \b基于 JavaScript, 一定要试试自己写插件； 跨平台 Mac、Windows、Linux； 做你能想到的任何事； 理论上 Alfred 能做的事情，Cerebro 同样能做到，更重要的是 跨平台开源免费！、跨平台开源免费！、跨平台开源免费！ 功能展示\b应用与文件搜索 基于 Electron，什么都能看 易上手的插件开发如果你正好是 JavaScript 的爱好者的话，这款\b软件绝对是你的大杀器，Cerebro \b的插件是同类软件中最容易上手开发的。只需要遵从 Cerebro API ，如果你连文档都懒得看的话，\b个人建议直接从插件列表 Awesome-cerebro 选一个改成你想要的样子就行，开源就是这么有魅力！ \b插件展示 密码管理 执行 Shell 命令 shell 搜索 npm 包 \b生成\b二维码 搜索 Emoji 表情 更多插件列表 Awesome-cerebro 我们写的一些插件Cerebro-torrent 我写的种子搜片儿神器 Cerebro-torrent 看个片儿还要打开网页慢慢找?！ Cerebro-codelf @carlos-wong 制作快速地变量名搜索神器 Cerebro-codelf 给变量起名的事情上，为你生命省 3s 结语如果你生活中存在着一些机械重复的\b劳动的话，比如煮个咖啡、回复相同内容的邮件、\b打开特定的网页等等，完全可以写成 Cerebro 插件提升效率，而节省下来的时间再用来改进工具，形成正循环！ 欢迎入坑 ~","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wangshub.github.io/tags/JavaScript/"},{"name":"Cerebro","slug":"Cerebro","permalink":"http://wangshub.github.io/tags/Cerebro/"}]},{"title":"cerebro-codelf给变量起名的事情上，为你生命省3s","slug":"cerebro-codelf给变量起名的事情上，为你生命省3s","date":"2018-04-30T12:11:27.000Z","updated":"2018-04-30T12:13:47.000Z","comments":true,"path":"2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/","link":"","permalink":"http://wangshub.github.io/2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/","excerpt":"","text":"cerebro-codelf There are only two hard things in Computer Science: cache invalidation and naming things. – Phil Karlton 给变量起名的事情上，为你生命省 3s。 Cerebro 变量名搜索插件，项目灵感来源 codelf。通过 Cerebro 的搜索窗口快速查找变量名。 特性 快速启动、搜索 中英文搜索 自由定制 安装 插件依赖于 Cerebro Ctrl-Space 打开 Cerebro 输入 plugins codelf，点击安装 使用 Cerebro 中，输入 codelf + [待搜索的变量名]； 上下选择变量名，敲回车 Enter 复制到剪切板； LICENSEMIT 项目地址 https://github.com/carlos-wong/cerebro-codelf 欢迎 fork :fork_and_knife: 和 star :star:","categories":[],"tags":[{"name":"JacaScript","slug":"JacaScript","permalink":"http://wangshub.github.io/tags/JacaScript/"},{"name":"Cerebro","slug":"Cerebro","permalink":"http://wangshub.github.io/tags/Cerebro/"}]},{"title":"python插件式爬虫","slug":"python插件式爬虫","date":"2018-04-25T07:51:05.000Z","updated":"2018-04-25T07:53:41.000Z","comments":true,"path":"2018/04/25/python插件式爬虫/","link":"","permalink":"http://wangshub.github.io/2018/04/25/python插件式爬虫/","excerpt":"","text":"Python 插件式的信息爬虫 🐝 一群不辞劳苦采花小蜜蜂 项目代码地址 本项目运行在可以运行在本地或者服务器端，将不同插件程序获取的信息如：每日天气、新闻等，通过 Github Api 上传到仓库进行保存。当然，你还可以你日常机械重复性的劳动在插件中帮你完成，比如煮咖啡、发邮件等等，真是棒极了。 额外收获 ：定期稳定运行在服务器上，还可以每日贡献一次 Github 贡献度 … 点亮你的人生！ 工程说明12345678├── app│ └── plugins│ └── weather.py├── builtin_plugins├── config│ └── config.json├── main.py└── upload_github.py main.py : 加载 builtin_plugins/ 和 app/ 下的插件； app/plugins/ : 插件程序存放路径； builtin_plugins ： 内置插件路径； upload_github.py : 通过 Github Api 提交一次 Commit； 使用步骤 生成 Github Token 运行代码 1python main.py 插件接口 Json 格式可以自己补充插件，各个插件的返回值为字典类型，必须满足如下格式 12345678&#123; \"code\": 0, \"type\": \"weather\", \"date\": \"2018-04-23 20:18:03\", \"content\": &#123; \"city\": \"\\u6df1\\u5733\", \"weather\": \"\\u591a\\u4e91\", \"temperature\": \"21 ~ 26\\u2103\", \"humidity\": \"\\u6e7f\\u5ea6\\uff1a63%\", \"wind\": \"\\u98ce\\u5411\\uff1a\\u5317\\u98ce 2\\u7ea7\", \"radiation\": \"\\u7d2b\\u5916\\u7ebf\\uff1a\\u5f31\", \"air\": \"PM: 43\" &#125;&#125; 参数说明 code: 0 成功、-1 失败； type: 例如 [weather, stock, news] 等； date: 当天日期，如 2018-05-01； content: 获取的 Json 格式信息，这部分提交到仓库保存； Todo Python 插件化信息管理，可拓展； 信息保存到 Github 仓库； 更多插件补充； [ ] Docker一键部署到本地或服务器； [ ] 信息可视化 Pyeacharts 网页显示 Gitpage 静态页面每日渲染 [ ] Itchat 微信推送 自动登录 自动推送 信息查询 [ ] 补充插件内容 插件思路收集 大新闻日常备份 商品价格记录插件","categories":[],"tags":[]},{"title":"Python插件式程序结构设计","slug":"Python插件式程序结构设计","date":"2018-04-23T06:27:19.000Z","updated":"2018-04-23T08:23:16.000Z","comments":true,"path":"2018/04/23/Python插件式程序结构设计/","link":"","permalink":"http://wangshub.github.io/2018/04/23/Python插件式程序结构设计/","excerpt":"","text":"Python 插件式程序结构设计 小姐姐，你的插件掉了 本文源码在 github/wangshub 最近有个问题一直困扰着我，我经常会遇到\b对以前的程序或者代码进行功能的\b扩充，但是由于前期没有太多程序架构上的设计，导致功能扩充时冗余代码太多，而且不方便维护( YC 创始人 Paul Graham 其实推荐这种做法，产品快速上线，获取用户反馈进行修改)。 知名的插件式设计的项目有 Emacs Vs-code Atom 为了拓展软件的功能，经常会将软件设计成插件式结构，所以就从我熟悉的 Python 开始了解这部分知识。通过 Google， 发现了 Pluginbase Python 插件框架，可以快速实现一个 Python 插件式结构，这篇博客作为阅读笔记。 项目文件结构12345678910├── app1│ └── plugins│ └── secret.py├── app2│ └── plugins│ └── randomstr.py├── builtin_plugins│ ├── lowercase.py│ └── uppercase.py└── example.py 插件管理器 获取当前项目的路径\b 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osfrom functools import partialfrom pluginbase import PluginBase# For easier usage calculate the path relative to here.here = os.path.abspath(os.path.dirname(__file__))# 函数包装，重新定义函数签名，减少调用参数get_path = partial(os.path.join, here)print('here:', here)print('get_path:', get_path)# Setup a plugin base for \"example.modules\" and make sure to load# all the default built-in plugins from the builtin_plugins folder.plugin_base = PluginBase(package='example.plugins', searchpath=[get_path('./builtin_plugins')])class Application(object): \"\"\"Represents a simple example application.\"\"\" def __init__(self, name): # Each application has a name self.name = name # And a dictionary where it stores \"formatters\". These will be # functions provided by plugins which format strings. self.formatters = &#123;&#125; # and a source which loads the plugins from the \"&#123;app_name&#125;/plugins\" # folder. We also pass the application name as identifier. This # is optional but by doing this out plugins have consistent # internal module names which allows pickle to work. self.source = plugin_base.make_plugin_source( searchpath=[get_path('./%s/plugins' % name)], identifier=self.name) # Here we list all the plugins the source knows about, load them # and the use the \"setup\" function provided by the plugin to # initialize the plugin. for plugin_name in self.source.list_plugins(): plugin = self.source.load_plugin(plugin_name) plugin.setup(self) def register_formatter(self, name, formatter): \"\"\"A function a plugin can use to register a formatter.\"\"\" self.formatters[name] = formatter \b实现插件插件 1 ： App112345678910111213import stringdef make_secret(s): chars = list(s) for idx, char in enumerate(chars): if char not in string.punctuation and not char.isspace(): chars[idx] = 'x' return ''.join(chars)def setup(app): app.register_formatter('secret', make_secret) 插件 2 ： App21234567891011121314import randomimport stringdef make_random(s): chars = list(s) for idx, char in enumerate(chars): if char not in string.punctuation and not char.isspace(): chars[idx] = random.choice(string.ascii_letters) return ''.join(chars)def setup(app): app.register_formatter('random', make_random) 内置插件123456def make_lowercase(s): return s.lower()def setup(app): app.register_formatter('lowercase', make_lowercase) \b调用你的插件1234567def run_demo(app, source): \"\"\"Shows all formatters in demo mode of an application.\"\"\" print('Formatters for %s:' % app.name) print(' input: %s' % source) for name, fmt in sorted(app.formatters.items()): print(' %10s: %s' % (name, fmt(source))) print('') 相关参考\b链接 如何设计插件式结构的程序，兼谈Python语言的动态性 A simple but flexible plugin system for Python. Python Classes PYTHON-进阶-FUNCTOOLS模块小结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"}]},{"title":"Cerebro插件之电影磁力搜索神器","slug":"Cerebro插件之电影磁力搜索神器","date":"2018-03-31T07:34:51.000Z","updated":"2018-03-31T07:36:01.000Z","comments":true,"path":"2018/03/31/Cerebro插件之电影磁力搜索神器/","link":"","permalink":"http://wangshub.github.io/2018/03/31/Cerebro插件之电影磁力搜索神器/","excerpt":"","text":"Cerebro 插件之电影磁力搜索神器 Cerebro plugin to search torrent of movies什么？看个片儿还要打开网页慢慢找?！ 这周在学 Node.js, 看了 @carlos-wong 推荐的《Eloquent JavaScript》 这本书的前几章，就抑制不住想写点什么练手。Cerebro 是一个跨平台的快速启动工具（同时支持 Windows、MacOs、Linux），并且可以用 Javascript 定制各种自己喜欢的插件。所以做了一个电影磁力搜索器的插件。 支持平台Windows、Linux、MacOS 截图 使用在 Cerebro 对话框中输入电影名称，使用键盘上/下按键选择电影，敲击 回车 ,磁力链接就会自动复制到剪贴板。 magnet [电影名称][空格] 安装步骤Cerebro 内安装插件 ctrl-space 启动 Cerebro 输入 plugins torrent 点击 install 源码安装 确保安装好了 Cerebro Clone 代码到本地，并执行 123git clone https://github.com/wangshub/cerebro-torrent.gitcd cerebro-torrentyarn install 将 cerebro-torrent 文件夹拷贝或者软链接到 Cerebro 的 node_module 文件夹下； 启动 Cerebro，输入 magnets 葫芦娃，然后敲击 空格； 稍等片刻，上下选择，敲击回车就可以将磁力链接复制到剪贴板； 打开迅雷或者其他下载器，尽情享受吧！ 原理说明 解析输入的指令； 利用 async 和 request 库并发爬取网站； 使用 cheerio 解析网页节点； 嵌入一段 html 对爬取结果进行显示； 代码地址欢迎 star ⭐️ 和 fork 💫 多提 Issue !wangshub/cerebro-torrent","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wangshub.github.io/tags/JavaScript/"}]},{"title":"如何解决EDAS上传论文时fonts问题","slug":"如何解决EDAS上传论文时fonts问题","date":"2018-02-10T09:29:54.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2018/02/10/如何解决EDAS上传论文时fonts问题/","link":"","permalink":"http://wangshub.github.io/2018/02/10/如何解决EDAS上传论文时fonts问题/","excerpt":"","text":"如何解决 EDAS 上传论文时 PDF fonts 问题问题描述今天在上传 IEEE xplore 论文时遇到上传字体出错的问题 1upload failed: One or more fonts are not embedded. See EDAS FAQ 解决办法检查字体子集在 EDAS 上传 Latex 输出的 PDF 文档时，需要检查 PDF 文档的中所有的字体是否是都是 已嵌入子集，检查方式是： 用 Acrobat pdf或 Foxit PDF工具打开待检查的 PDF 文件 paper.pdf 打开 文件(file)-&gt;属性(property)-&gt;字体(fonts) 查看所有的字体是否是已嵌入或者已嵌入子集 更改字体如果出现未嵌入的子集 helvitica helvitica字体未嵌入的原因是论文中使用了Matlab生成的图像，Matlab 默认使用了 Helvetica 字体，Latex 在引用该图片时，也默认使用了 Helvetica 字体，导致生成的 PDF 文件不能将这个字体嵌入。 解决步骤： 如果是引用的图片是pdf格式，需要使用 shell 命令ps2pdf13，将Helvetica 进行转化 1ps2pdf13 -dPDFSETTINGS=/prepress fig_non_embedded.pdf fig_embedded.pdf 如果你需要嵌入 *.esp图片文件到你的 Latex 文章中，还需要将步骤1中的 *.pdf 转成 *.esp 文件 1pdftops -eps -level2 [pdfname] [epsname] 参考链接https://sites.google.com/site/xyzliwen/resource/embed_font_ieee_pdf_explore http://www.mit.edu/~kimo/blog/matlab_figures.html ​","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"http://wangshub.github.io/tags/latex/"}]},{"title":"python装饰器学习笔记","slug":"python装饰器学习笔记","date":"2018-02-07T06:02:39.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2018/02/07/python装饰器学习笔记/","link":"","permalink":"http://wangshub.github.io/2018/02/07/python装饰器学习笔记/","excerpt":"","text":"python 装饰器学习笔记概括 装饰器的作用就是为已经存在的对象添加额外的功能 我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样就提高了程序的可重复利用性，并增加了程序的可读性。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"用python对github用户followers分析","slug":"用python对github用户followers分析","date":"2018-01-15T01:40:16.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2018/01/15/用python对github用户followers分析/","link":"","permalink":"http://wangshub.github.io/2018/01/15/用python对github用户followers分析/","excerpt":"","text":"github 用户 followers 分析如何分析一个github用户的followers？ 周末手痒，用python分析了一下自己 github 的 followers 用户，统计结果如下 问题分析在github上，一个用户的主页显示如下，主要对如下用户信息进行提取 用户名称 所在的位置 用户仓库、stars、Followers、Following数量 去年一年的贡献度 我们需要对上图红框里面的数据进行提取，最直接的方法是使用requests，通过BeautifulSoup对html中的信息进行提取。 一些弯路最开始没打算用爬虫的方式来获取用户信息，因为github有公开的REST API v3可以对指定用户的信息进行访问，并且已经有打包好的PyGithub方便调用。但是我实验下来有如下问题所以放弃使用REST API v3 API请求频率有限制，无法运用多线程快速获取批量的用户信息 不知道是不是小BUG，通过API无法获得用户去年一年的贡献度contributions 工具 python 3 ： 彻底告别我的py2 BeaufulSoup ：从HTML或XML文件中提取数据 Requests ： 请求网页 多进程 ： 为了更快 pyecharts ： 美的令人窒息的绘图工具 操作步骤 获取目标用户如https://github.com/wangshub?page=1&amp;tab=followers的所有followers； 改变page编号，遍历所有用户； 提取用户关键信息，保存成csv文件； 数据清洗，过滤； 利用pyecharts绘图； 进行地点词频统计； 实验结果截止2018-01-15,我的github账号一共有1214名follower，分析结果如下 用户地点分析排除掉没有填写地点信息的用户，将中文转化成pinyin后，词云如下 用户基本上都是来自北京、上海、深圳等地 去年一年用户贡献度分析如果看用户是否活跃，肯定是看contributions啦 可以看出超过一般多的用户，去年的贡献度都在都在 1~50 之间，新的一年要加油啦。其中一年贡献最多的用户是@dragon-yuan, 在2017年有整整 4,197 个贡献度，不多说了，前去关注一波。 用户followers分析哇，有大牛，别拦着我，我要去点关注了 用户仓库数量分析通过爬取用户的仓库数量，进行统计如下 可以看到一个有意思的现象，有少数的人仓库数量超过了1000，打开这几位仁兄的github主页，大部分是fork的项目，其中仓库最多的用户有13100个仓库，叫@ProgrammerAndHacker，他是这么介绍自己的1234I follow best programmer and hacker， Do you want to hacked by them? ^_^ Best programmers and hackers are here: ... 用户stars分析都说点击star是一个好习惯， 不得不说，github上面还是有点赞狂魔的，这位老铁@chenruibin一共点击了10100个赞，真是好习惯～ 用户 following 分析 同样是@ProgrammerAndHacker这位仁兄，一共follow了19600个用户，严重怀疑是不是机器人。 最后不搞了，我要去写论文了TAT，要代码的，来这里找https://github.com/wangshub/who_is_following","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"github","slug":"github","permalink":"http://wangshub.github.io/tags/github/"}]},{"title":"教你用Python来玩微信跳一跳","slug":"教你用Python来玩微信跳一跳","date":"2017-12-29T02:02:41.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/29/教你用Python来玩微信跳一跳/","link":"","permalink":"http://wangshub.github.io/2017/12/29/教你用Python来玩微信跳一跳/","excerpt":"","text":"教你用Python来玩微信跳一跳 2017年12月28日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 demo「跳一跳」。 blog 地址 github 地址 知乎专栏 游戏模式这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。玩法类似于《flappy bird》 如果能精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃？所以花2个小时写了一个python脚本进行验证 工具介绍 Python 2.7 Android 手机 Adb 驱动 Python Matplot绘图 原理说明 将手机点击到《跳一跳》小程序界面； 用Adb 工具获取当前手机截图，并用adb将截图pull上来 12adb shell screencap -p /sdcard/1.pngadb pull /sdcard/1.png . 用matplot显示截图； 用鼠标点击起始点和目标位置，计算像素距离； 根据像素距离，计算按压时间； 用Adb工具点击屏幕蓄力一跳； 1adb shell input swipe x y x y time 实验结果 TODO可以对拉上来的图片进行颜色分割，识别小人和目标中心店，这样就不需要手动点击自动弹跳。事实证明，机器人比人更会玩儿游戏。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"Python蔡英文facebook主页分析_by神奇的战士","slug":"Python蔡英文facebook主页分析-by神奇的战士","date":"2017-12-25T07:14:39.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/","link":"","permalink":"http://wangshub.github.io/2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/","excerpt":"","text":"Python蔡英文facebook主页分析(by神奇的战士) 博客地址：https://wangshub.github.io/ 公众号：舒林笑笑生 拒绝转载 用Facebook Graph API和情绪分析API对蔡英文Facebook主页进行统计分析。 1. 说明蔡英文2016年5月20日，蔡英文正式就任台湾地区领导人，成为台湾地区首位女性领导人。 最近台湾省地区新闻主要有： 新闻来源： 人民网坚决惩治电信诈骗犯罪 切实维护两岸同胞利益两岸学者评新党人士被调查事件：民进党当局逆流而动终将自掘坟墓台民众高呼“醒来”，蔡英文不能继续装睡… 但是真实的台湾同胞们是如何看待她的执政表现呢？ 2. 实现工具如果是直接爬取脸书的主页，需要进行模拟登陆，反爬虫，代理，验证等等一系列的操作。幸好脸书开放出了图API，可以在一定的请求限制下对脸书上的数据进行访问。注意在多线程请求API的时候，不应该请求的太快，否则会被系统封禁一段时间(不要问我为什么-_-)。 目前为止使用了如下这些工具： python 2.7 Facebook Graph API 情感分析API python 词云 python 中文jieba分词 python Pandas python 多线程 3. 数据处理3.1 posts首先测试脸书Facebook Graph API，对蔡小姐的post进行访问， curl测试脚本 12curl -i -X GET \\ \"https://graph.facebook.com/v2.11/tsaiingwen/posts?access_token=xxxxxxxxxxxxxxxxx\" 返回示例 1234567891011121314151617\"data\": [ &#123; \"created_time\": \"2017-12-24T11:50:06+0000\", \"message\": \"蔡想想🐱祝福大家聖誕快樂🎅 #MerryChristmas\", \"id\": \"46251501064_10154820163381065\" &#125;, ... ...],\"paging\": &#123; \"cursors\": &#123; \"before\": \"xxxxxx\", \"after\": \"xxxxx\" &#125;, \"next\": \"xxxxxxxxxxxxxxxxxxxxxx\" &#125; 可以观察到，脸书的每一个post都对应了一个唯一的id，由于post的数量是在太多，所以一次请求无法完整获取。根据next可以得到下一页的post，直到next为空时，表示所有的post获取完毕。 根据以上原理，我获取了蔡小姐从开通脸书第一天起到今天，发的每一条post。 横坐标：时间 纵坐标：每天发文数量 自 2008-10-22T13:55:20+0000蔡小姐发了第一条post以来，一共发了4120篇状态，基本上在脸书上还是非常活跃的，在2012年最多一天发送了24条状态，成功刷屏。 3.2 comments与 3.1节类似，每一个post下都会有网友进行评论，那么如何获取所有评论?参考图谱API文档，利用测试脚本 curl测试脚本 12curl -i -X GET \\ \"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxxxxxx\" 返回示例 12345678910111213141516&#123; \"data\": [ &#123; \"created_time\": \"2017-11-13T07:15:25+0000\", \"message\": \"XXXXXXXX\", \"id\": \"10154729068451065_10154729097936065\" &#125;, ... ... \"paging\": &#123; \"cursors\": &#123; \"before\": \"MTQyNQZDZD\", \"after\": \"MTM5MQZDZD\" &#125;, \"next\": \"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxx&amp;pretty=0&amp;limit=25&amp;after=MTM5MQZDZD\" &#125; 每一条评论都对应着唯一的id，next字段是下一页的评论内容。可以通过设置，选择一夜最多显示100条评论。以此逐级获取所有的评论。 横坐标：时间 纵坐标：每条状态对应的评论数量 一共爬取了1830322条网友评论，最多评论数是23630条。其中几次出现了较大值，原因应该是前几次大陆网友自发组织的Facebook远征军去进行友好访问了。具体内容可以接下来对这几次的峰值进行详细分析。 相关新闻：帝吧“远征”facebook｜一场表情包大战的爱国交流如何评价李毅吧 2016 年 1 月 20 日「出征」Facebook？ 4. 数据分析4.1. 蔡英文主页分析一共获取了蔡小姐的4120状态，对json的message字段进行提取，将所有的状态的文字保存进行词云分析，看哪些词汇出现的频率最高。 首先利用Pandas对状态的结构数据进行保存； 读取Pandas表格，获取所有的状态文字； 利用jieba中文分词库，对所有的文字进行分割； 显示，保存图片； 蔡小姐词云 4.2. 蔡英文评论分析从蔡小姐的post的所有评论当中，我找出了一条评论最多的状态，共有23630条评论，对应id为46251501064_10154244975341065，读取对应数据文件，利用词云分析可得 看来台湾网友也十分注意安全开车，其实这条post的评论区被台湾网友刷屏了，看来怨气挺重呢，哈哈哈哈，霸屏具体内容是12345671.政府請正視目前台灣改裝汽機車問題！排氣管及改裝品可以合法製造 合法販賣 合法進口但裝載車上就不合法 這是什麼邏輯 政府要課稅又要開罰單又是什麼想法？排氣管或車上零件是原廠被惡意檢舉驗車那是否能跟監理單位或環保署拿今日上班請假損失？2.環保局 監理站 警察執法單位 專業度嚴重不足 原廠排氣管也開單 叫民眾到監理單位驗車 當做民眾都很有時間？3.請提供可比照國外變更車體，如重機行李箱、遮陽板、避震、制動煞車系統在不影響行車安全的部份合乎法規4.如民眾遭受到檢舉達人惡意檢舉，因此需要請假驗車，若屬於惡意檢舉，政府需要支付民眾請假之當天工資蔡??...您不是希望台灣能跟世界接軌，那請您重視汽機車改裝合法性與可變更性，在不影響行車安全與噪音的&gt; 情況下，請把檢舉改裝還於司法單位執行，才不構成擾民。 既然这条被刷屏了，那就换成最新的一篇post，看看网友又关心啥问题。。。截止爬取脸书时，最新一条博客是： 12345你有吃過越南生春捲、香蘭娘惹糕或是薑黃飯嗎？它們是來自東南亞各國的美食，現在也是台灣的美食。今天是國際移民日，前幾天，我邀請了幾位新移民的好朋友來到總統府，一起準備午餐。在這場午餐的約會中，他們和我分享來到台灣生活的點點滴滴，也給我很多建議。謝謝你們來到台灣，讓我們的社會更多元、更茁壯。祝大家國際移民日快樂！#留言告訴我你最喜歡的新南向美食#晚餐文&quot;, 蔡小姐问网友喜欢吃啥美食，我们来看看网友是如何回复的 结合最近的新党王炳忠事件，评论中出现了较多绿色恐怖、王炳忠、白色恐怖等高频词汇 5. TODO可以分析的数据还有很多，就先分析这么多了，接下来，可以对评论进行情感分析，看下网友对蔡小姐的评论是积极还是消极的多一些。不过经过这一年的时间来看，应该是消极多一点。哈哈哈 总结下来，我认为： 台湾社会的认知是处于一个分裂的状态； 不少年轻人还是无脑反对大陆； 真正理性思考人太少； 不少人处于岛内的小确幸当中； 结合最近的新闻来看，猜测台湾的士兵在开战时会不会遇到为了什么而战斗的信仰问题。哈哈，一百分将军太逗啦","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"linux驱动器和分区的备份，使用dd命令示例","slug":"linux驱动器和分区的备份，使用dd命令示例","date":"2017-12-18T12:04:51.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","link":"","permalink":"http://wangshub.github.io/2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","excerpt":"","text":"dd命令是Linux发行版非常简单的备份工具。 “dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。dd 命令是Linux发行版非常简单的备份工具。该“dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 用dd命令，我们可以创建整盘，磁盘驱动器等备份，下面这篇文章将帮助你学习一些有用的“dd”命令。 1：创建现有分区备份以下命令将整个分区/dev/sdb1备份到/opt/sdb1.img文件。 # dd if=/dev/sdb1 of=/opt/sdb1.img 样本输出12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 123.319 s, 66.7 MB/s 2：恢复备份到其他分区上面 /opt/sdb1.img备份文件可以恢复到其他分区（/dev/sdb2），我们可以用以下命令恢复。 # dd if=/opt/sdb1.img of=/dev/sdb2 样本输出12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 197.688 s, 41.6 MB/s 现在，你可以看到的/dev/sdb2 是/dev/sdb1 的翻版。 3：创建与现有分区副本我们可以直接从现有的分区副本来分区。以下命令将创建的/dev/sdb1 到 /dev/sdb2 的副本。 # dd if=/dev/sdb1 of=/dev/sdb2 样本输出12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 221.431 s, 37.1 MB/s 4：创建现有的硬盘克隆以下命令将复制前446个字节这是MBR从第一个磁盘到第二个磁盘。这将创建第二个磁盘引导。 。 # dd if=/dev/sda of=/dev/sdb bs=446 count=1 1231+0 records in1+0 records out446 bytes (446 B) copied, 0.00174812 s, 255 kB/s 现在确保在/dev/sdb的匹配为/dev/sda的分区。一旦做到这一点，您可以使用复制每个分区： # dd if=/dev/sda1 of=/dev/sdb1 # dd if=/dev/sda2 of=/dev/sdb2 5：备份和恢复的MBR镜像文件创建使用以下命令MBR的镜像文件的备份。 # dd if=/dev/sda of=/opt/backup-mbr-sda.img bs=512 count=1 示例输出1231+0 records in1+0 records out512 bytes (512 B) copied, 0.0115243 s, 44.4 kB/s 接下来的步骤是MBR恢复到不同的磁盘，使用下面的命令来做到这一点。 # dd if=/opt/backup-mbr-sda.img of=/dev/sdb bs=446 count=1","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"}]},{"title":"python数字图像处理-图像噪声与去噪算法","slug":"python数字图像处理-图像噪声与去噪算法","date":"2017-12-16T09:19:29.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/16/python数字图像处理-图像噪声与去噪算法/","link":"","permalink":"http://wangshub.github.io/2017/12/16/python数字图像处理-图像噪声与去噪算法/","excerpt":"","text":"python数字图像处理-图像噪声与去噪算法 figure_1.png 图像噪声椒盐噪声概述： 椒盐噪声（salt &amp; pepper noise）是数字图像的一个常见噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。椒盐噪声是一种因为信号脉冲强度引起的噪声，产生该噪声的算法也比较简单。 给一副数字图像加上椒盐噪声的步骤如下： 指定信噪比 SNR （其取值范围在[0, 1]之间） 计算总像素数目 SP， 得到要加噪的像素数目 NP = SP * (1-SNR) 随机获取要加噪的每个像素位置P（i, j） 指定像素值为255或者0。 重复3,4两个步骤完成所有像素的NP个像素 输出加噪以后的图像 高斯噪声概述： 加性高斯白噪声(Additive white Gaussian noise，AWGN)在通信领域中指的是一种功率谱函数是常数(即白噪声), 且幅度服从高斯分布的噪声信号. 这类噪声通常来自感光元件, 且无法避免. 去噪算法中值滤波概述： 中值滤波是一种非线性空间滤波器, 它的响应基于图像滤波器包围的图像区域中像素的统计排序, 然后由统计排序结果的值代替中心像素的值. 中值滤波器将其像素邻域内的灰度中值代替代替该像素的值. 中值滤波器的使用非常普遍, 这是因为对于一定类型的随机噪声, 它提供了一种优秀的去噪能力, 比小尺寸的均值滤波器模糊程度明显要低. 中值滤波器对处理脉冲噪声(也称椒盐噪声)非常有效, 因为该噪声是以黑白点叠加在图像上面的. 与中值滤波相似的还有最大值滤波器和最小值滤波器. 均值滤波概述： 均值滤波器的输出是包含在滤波掩模领域内像素的简单平均值. 均值滤波器最常用的目的就是减噪. 然而, 图像边缘也是由图像灰度尖锐变化带来的特性, 所以均值滤波还是存在不希望的边缘模糊负面效应. 均值滤波还有一个重要应用, 为了对感兴趣的图像得出一个粗略描述而模糊一幅图像. 这样, 那些较小物体的强度与背景揉合在一起了, 较大物体变得像斑点而易于检测.掩模的大小由即将融入背景中的物体尺寸决定. 代码见https://github.com/wangshub/python-image-process","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://wangshub.github.io/tags/image/"}]},{"title":"python数字图像处理-图像的基本结构和基础知识","slug":"python数字图像处理-图像的基本结构和基础知识","date":"2017-12-16T09:10:39.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/16/python数字图像处理-图像的基本结构和基础知识/","link":"","permalink":"http://wangshub.github.io/2017/12/16/python数字图像处理-图像的基本结构和基础知识/","excerpt":"","text":"数字图像处理-图像的基本结构和基础知识 LenaRGB.bmp 一、python实现BMP图像的读取和显示BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的重要来源。Windows的图形用户界面（graphical user interfaces）也在它的内建图像子系统GDI中对BMP格式提供了支持。 BMP文件的数据按照从文件头开始的先后顺序分为四个部分： bmp文件头(bmp file header) ：提供文件的格式、大小等信息 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息 调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表 位图数据(bitmap data)：就是图像数据 参考链接https://zh.wikipedia.org/wiki/BMP 二、python统计图像的直方图图像直方图（英语：Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。可以借助观察该直方图了解需要如何调整亮度分布。这种直方图中，横坐标的左侧为纯黑、较暗的区域，而右侧为较亮、纯白的区域。因此，一张较暗图片的图像直方图中的数据多集中于左侧和中间部分；而整体明亮、只有少量阴影的图像则相反。很多数码相机提供图像直方图功能，拍摄者可以通过观察图像直方图了解到当前图像是否过分曝光或者曝光不足。计算机视觉领域常借助图像直方图来实现图像的二值化 2 统计直方图.png 参考链接https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE#%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE 三、RGB、YIQ、HSI、XYZ颜色空间YIQYIQ色彩空间通常被北美的电视系统所采用，属于NTSC（National Television Standards Committee）系统。这里Y不是指黄色，而是指颜色的明视度（Luminance），即亮度（Brightness）。其实Y就是图像的灰度值（Gray value），而I和Q则是指色调（Chrominance），即描述图像色彩及饱和度的属性。在YIQ系统中，Y分量代表图像的亮度信息，I、Q两个分量则携带颜色信息，I分量代表从橙色到青色的颜色变化，而Q分量则代表从紫色到黄绿色的颜色变化。 NTSC制为了进一步压缩色度带宽，用色差信号I,Q来代替U,V。若采用U,V色差信号，则色度、亮度信号的共频带部分极大，低端不共频带的亮度信号带宽很小，亮、色干扰大。将彩色图像从RGB转换到YIQ色彩空间，可以把彩色图像中的亮度信息与色度信息分开，分别独立进行处理。 RGB和YIQ的对应关系用下面的方程式表示：123Y=0.299R+0.587G+0.114BI=0.596R-0.274G-0.322BQ=0.211R-0.523G+0.312B 3 YIQ分量.png HSI 色调H（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。 饱和度S（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。 亮度I（Intensity）：对应成像亮度和图像灰度，是颜色的明亮程度。若将RGB单位立方体沿主对角线进行投影，可得到六边形，这样，原来沿主对角线的灰色都投影到中心白色点，而红色点（1，0，0）则位于右边的角上，绿色点（0，1，0）位于左上角，蓝色点（0，0，1）则位于左下角。 HSI颜色模型的双六棱锥表示，I是强度轴，色调H的角度范围为[0，2π]，其中，纯红色的角度为0，纯绿色的角度为2π/3，纯蓝色的角度为4π/3。饱和度S是颜色空间任一点距I轴的距离。当然，若用圆表示RGB模型的投影，则HSI色度空间为双圆锥3D表示。 注意： 当强度I=0时，色调H、饱和度S无定义；当S=0时，色调H无定义。HSI模型也可用圆柱来表示，如图9-5所示。若将其展开，并按图9-6进行定义，可得到HSI调色板。 HSI_Formula.jpg 5 HSI分量.png XYZ国际照明委员会(CIE)在进行了大量正常人视觉测量和统计,1931年建立了”标准色度观察者”， 从而奠定了现代CIE标准色度学的定量基础。由于”标准色度观察者”用来标定光谱色时出现负 刺激值，计算不便，也不易理解，因此1931年CIE在RGB系统基础上，改用三个假想的原色X、Y、 Z建立了一个新的色度系统。将它匹配等能光谱的三刺激值，定名为”CIE1931 标准色度观察者 光谱三刺激值”，简称为”CIE1931标准色度观察者”。这一系统叫做”CIE1931标准色度系统”或称为” 2° 视场XYZ色度系统”。CIEXYZ颜色空间稍加变换就可得到Yxy色彩空间，其中Y取三刺激值中Y的值， 表示亮度，x、y反映颜色的色度特性。定义如下：在色彩管理中，选择与设备无关的颜色空间是 十分重要的，与设备无关的颜色空间由国际照明委员会(CIE)制定，包括CIEXYZ和CIELAB两个标准。 它们包含了人眼所能辨别的全部颜色。而且，CIEYxy测色制的建立给定量的确定颜色创造了条件。 但是，在这一空间中，两种不同颜色之间的距离值并不能正确地反映人们色彩感觉差别的大小， 也就是说在CIEYxy色厦图中，在 不同的位置不同方向上颜色的宽容量是不同的，这就是Yxy颜色空间 的不均匀性。这一缺陷的存在，使得在Yxy及XYZ空间不能直观地评价颜色。 xyz.jpg 6 XYZ分量.png 四、python代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#encoding: utf-8import numpy as npfrom PIL import Imageimport matplotlib.pyplot as pltimport mathdef show_bmp(img): # BMP 的读取与显示 plt.figure(\"LenaRGB.bmp\") plt.title(\"LenaRGB.bmp\") plt.imshow(img) plt.show()def show_hist(img): # 直方图 plt.figure(\"Lena hist\") plt.title('Lena hist figure') arr = img.flatten() n, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor='green', alpha=0.75) plt.show()def show_rgb(img): # 显示RGB图像 plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('R') plt.imshow(img[:, :, 0], cmap='gray') plt.subplot(223) plt.title('G') plt.imshow(img[:, :, 1], cmap='gray') plt.subplot(224) plt.title('B') plt.imshow(img[:, :, 2], cmap='gray') plt.show()def shou_yiq(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) Y = 0.299 * R + 0.587 * G + 0.114 * B I = 0.596 * R - 0.274 * G - 0.322 * B Q = 0.211 * R - 0.523 * G - 0.312 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(223) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(224) plt.title('Q') plt.imshow(Q, cmap='gray') plt.show() # YIQ = def show_xyz(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) X = 0.490 * R + 0.310 * G + 0.200 * B Y = 0.177 * R + 0.813 * G + 0.011 * B Z = 0.000 * R + 0.010 * G + 0.990 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('X') plt.imshow(X, cmap='gray') plt.subplot(223) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(224) plt.title('Z') plt.imshow(Z, cmap='gray') plt.show()def show_hsi(img): rows, cols, dims = img.shape R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) I = (R + G + B) / 3 E = np.mat(np.ones([rows, cols])) minRGB = np.mat(img.min(2)) lv = 3 * E / (R + G + B) S = E - np.multiply(lv, minRGB) # S = np.mat(np.zeros([rows, cols])) # for i in range(rows): # for j in range(cols): # S[i, j] = 1 - 3/(R[i, j] + G[i, j] + B[i, j]) * min([R[i, j], G[i, j], B[i, j]]) H = np.mat(np.zeros([rows, cols])) for i in range(rows): for j in range(cols): up = (R[i, j] - G[i, j] + R[i, j] - B[i, j]) / 2 down = (R[i, j] - G[i, j])**2 + (R[i, j] - B[i, j]) * (G[i, j] - B[i, j])**0.5 H[i, j] = math.acos(up / down) plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(223) plt.title('S') plt.imshow(S, cmap='gray') plt.subplot(224) plt.title('H') plt.imshow(H, cmap='gray') plt.show()def main(): img = np.array(Image.open('/home/sun/Desktop/PycharmProjects/Digital_image_process_lxk/lab1/LenaRGB.bmp')) rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # show_bmp(img) # show_hist(img) # show_rgb(img) # shou_yiq(img) # show_hsi(img) # show_xyz(img)if __name__ == '__main__': main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://wangshub.github.io/tags/image/"}]},{"title":"python：将图片转换成excel文档","slug":"image-to-excel","date":"2017-12-14T13:28:12.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/12/14/image-to-excel/","link":"","permalink":"http://wangshub.github.io/2017/12/14/image-to-excel/","excerpt":"","text":"python：将图片转换成excel文档实现步骤 读取图像，获取图像每个像素点的RGB值； 根据每个像素点的RGB值设置excel每个方格的颜色值； 根据像素点的坐标，写入excel文件； 保存退出； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from PIL import Imageimport numpy as npimport timeimport matplotlib.pyplot as pltimport xlsxwriterdef get_xy(row, col): table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' num1 = col / 26 num2 = col % 26 # print num1, num2 if num1 == 0: return table[num2 - 1] + str(row) else: return table[num1-1] + table[num2 - 1] + str(row)def main(): img = np.array(Image.open('whale.jpeg')) # plt.figure(\"whale\") # plt.imshow(img) # plt.show() rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # print img[188, 188, 0] excel = xlsxwriter.Workbook('image_excel.xlsx') cellformat = excel.add_format(&#123;'bg_color': '#123456', 'font_color': '#654321'&#125;) worksheet1 = excel.add_worksheet() data = [] color = [''] * cols cellcolor = \"\" for i in range(rows): for j in range(cols): # print hex(img[i, j, 0]), hex(img[i, j, 1]), hex(img[i, j, 2]) cellcolor = (hex(img[i, j, 0]) + hex(img[i, j, 1]) + hex(img[i, j, 2])).replace('0x', '') # print cellcolor cellformat = excel.add_format(&#123;'bg_color': '#'+cellcolor, 'font_color': '#'+cellcolor&#125;) # cellformat = excel.add_format(&#123;'bg_color': '#C6EFCE', # 'font_color': '#006100'&#125;) worksheet1.conditional_format(get_xy(i, j), &#123;'type': 'cell', 'criteria': '&lt;', 'value': 50, 'format': cellformat&#125;) # data.append(data_row) excel.close() if __name__ == '__main__': main() # print get_xy(133, 27)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"python check hosts update","slug":"python-check-hosts-update","date":"2017-07-20T14:33:15.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/07/20/python-check-hosts-update/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-check-hosts-update/","excerpt":"","text":"用Python检查 hosts 更新最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者是否有更新。所以这种苦力活就让Python干好了。 hosts地址_hostsinfo.py1hosts_source = [\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\"] 检查hosts是否有更新_checkhosts.py1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllib2from .hosts_info import *import osimport filecmpdef hosts_download(): if os.path.exists('hosts'): hosts_name = 'hosts_new' else: hosts_name = 'hosts' # todo: overtime detection f = urllib2.urlopen(hosts_source[0]) print \"downloading hosts\" with open(hosts_name, \"wb\") as code: code.write(f.read())def is_hosts_new(): hosts_download() if not os.path.exists('hosts'): print 'oops, hosts not exists' return -1 elif os.path.exists('hosts') and (not os.path.exists('hosts_new')): print 'first run, only one hosts file' return True elif os.path.exists('hosts') and (os.path.exists('hosts_new')): print 'compare hosts &amp; hosts_new' diff_status = filecmp.cmp('hosts', 'hosts_new') if diff_status: print 'same file' os.remove('hosts_new') return False else: print 'diff file' os.remove('hosts') os.rename('hosts_new', \"hosts\") return True else: return -1 主程序调用main.py1234567from check_hosts.check_hosts import *diff_status = is_hosts_new()if diff_status: print \"new hosts !\"else: print 'code: ',diff_status","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"VPN","slug":"Python/VPN","permalink":"http://wangshub.github.io/categories/Python/VPN/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"VPN","slug":"VPN","permalink":"http://wangshub.github.io/tags/VPN/"}]},{"title":"python mail sender","slug":"python-mail-sender","date":"2017-07-20T14:22:06.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/07/20/python-mail-sender/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-mail-sender/","excerpt":"","text":"python 发送邮件配置服务器和邮箱 mail_info.py123456mail_host = 'smtp.yeah.net'mail_user = 'mail_name'mail_pass = 'mail_password'sender = 'mail_name@yeah.net'receivers = ['target@mail.com'] 发送邮件 mail_trans.py1234567891011121314151617181920212223from .mail_info import *import smtplibfrom email.mime.text import MIMETextdef mail_text_send(title, text): message = MIMEText(text, 'plain', 'utf-8') message['Subject'] = title message['From'] = sender message['To'] = receivers[0] try: smtpObj = smtplib.SMTP() # connect host smtpObj.connect(mail_host, 25) # login host smtpObj.login(mail_user, mail_pass) # send smtpObj.sendmail(sender, receivers, message.as_string()) # quit smtpObj.quit() return True except smtplib.SMTPException as e: return False 主程序调用 main.py12from mail_trans import *mail_text_send('title', 'hello world!')","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"},{"name":"Mail","slug":"Python/Code/Mail","permalink":"http://wangshub.github.io/categories/Python/Code/Mail/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"Mail","slug":"Mail","permalink":"http://wangshub.github.io/tags/Mail/"}]},{"title":"使用python备份博客图床图片","slug":"use-python-to-backup-markdown-images","date":"2017-06-05T15:09:29.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/06/05/use-python-to-backup-markdown-images/","link":"","permalink":"http://wangshub.github.io/2017/06/05/use-python-to-backup-markdown-images/","excerpt":"","text":"说明最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误.所以花了一点时间,用python 正则匹配 markdown中图片链接,然后下载图片保存到本地文件夹img中.这样就不用担心图片失效啦,当我找到稳定的图床,可以随时把这些图片再上传更新,美滋滋~~~ 功能 .md文件自动搜索 正则匹配图片链接 爬取图片内容 保存文本到本地 步骤读取文件 =&gt; 正则匹配 =&gt; 图片下载 =&gt; 保存本地 python代码详细见我的github地址: www.github.com/wangshub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# coding=utf-8import sysimport osimport reimport requestsimport urllibimport urllib2def search(path, word): for filename in os.listdir(path): fp = os.path.join(path, filename) if os.path.isfile(fp) and word in filename: print fp download(str(fp)) elif os.path.isdir(fp): search(fp, word)def download(file_path): # filename = \"test\" name = file_path.split(u\"/\") filename = name[-1] f_md = open(file_path) # all text of md file text = f_md.read().decode('utf-8') # regex img_reg = r'\\!&#123;1&#125;\\[(.*?)\\]\\((.*?)\\)' result = re.findall('!\\[(.*)\\]\\((.*)\\)', text) for i in range(len(result)): img_quote = result[i][0] img_url = result[i][1] # download img request = urllib2.Request(img_url) response = urllib2.urlopen(request) img_contents = response.read() # img name spell urlname = img_url.split(u\"/\") img_name = filename + '_' + \\ str(i) + '_' + img_quote + str(urlname[len(urlname) - 1]) print img_name, '~~~', img_url # write to file f_img = open('img/' + img_name, 'wb') f_img.write(img_contents) f_img.close() f_md.close()search(sys.argv[1], '.md') 食用方法python md_image_bacup.py /path/to/your/file/ 作者 Author : WangSongE-mail : easternslope@yeah.net","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"markdown","slug":"python/markdown","permalink":"http://wangshub.github.io/categories/python/markdown/"},{"name":"code","slug":"python/markdown/code","permalink":"http://wangshub.github.io/categories/python/markdown/code/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"markdown","slug":"markdown","permalink":"http://wangshub.github.io/tags/markdown/"}]},{"title":"从机sshfs访问主机文件系统","slug":"sshfs-mount-net-disk","date":"2017-05-31T13:16:00.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/31/sshfs-mount-net-disk/","link":"","permalink":"http://wangshub.github.io/2017/05/31/sshfs-mount-net-disk/","excerpt":"","text":"说明需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到scp命令 scp -r /主机/文件 从机名@192.168.x.x:从机目录/.利用sshfs可以直接在从机进行编译,省略拷贝步骤. 系统结构框图Linux 主机 &lt;=====&gt; Linux 从机 操作步骤 主机 sudo apt-get install openssh-server ifconfig -a获取局域网内 IP地址 从机 sudo apt-get install sshfs sshfs -o idmap=user -o reconnect host_name@192.168.20.236:/path/to/your/workspace /path/to/your/workspace 现在可以从从机开心地访问主机文件了 author : Wangsongmail : easternslope@yeah.net","categories":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/categories/linux/"},{"name":"tool","slug":"linux/tool","permalink":"http://wangshub.github.io/categories/linux/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"},{"name":"tool","slug":"tool","permalink":"http://wangshub.github.io/tags/tool/"}]},{"title":"python 数据结构之二叉搜索树","slug":"python-data-structure-BST","date":"2017-05-29T15:06:12.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/29/python-data-structure-BST/","link":"","permalink":"http://wangshub.github.io/2017/05/29/python-data-structure-BST/","excerpt":"","text":"二叉搜索树定义一颗二叉搜索树是以二叉树来组织的,每个节点除了 Key 还包括 左孩子, 右孩子, 父节点 等信息. BST满足限制条件: 对于任意节点的X,他的 左子树中关键字最大值&lt;=X.key , 右子树关键字最小值&gt;=X.key 这个关系表示如下 二叉 根据上图定义,一个二叉搜索树的例子是 二叉树操作 查询 插入 删除 查询(搜索)二叉树搜索采用递归的方式来进行查询,根据二叉搜索树的定义: 左子树存储小值, 右子树存储大值,一个完整的二叉搜索示意图如下 可以写成 伪代码 1234567TREE-SEARCH(x, k) if x == NULL or k == x.key return x if k &lt; x.key return TREE-SEARCH(x.left) if k &gt; x.key return TREE-SEARCH(x.right) 转换成python代码 12345678910111213141516171819def _get(self, key, node): if node is None: return None if key &lt; node.key: return self._get(key, node.left) elif key &gt; node.key: return self._get(key, node.right) else: return node.valdef get(self, key): \"\"\" Return the value paired with 'key' Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" return self._get(key, self.root) 插入插入和删除比查询呢稍微复杂一些,因为该操作会引起二叉搜索树的大小变化,会改变动态集合的结构.插入呢又比删除稍微容易实现.插入分为两部 查询插入节点 改变目标节点附近的数据结构 插入过程示意图如下 相应的伪代码如下, 输入节点 z , z.key = v, z.left = NULL, z.right = NULL. 12345678910111213141516TREE-INSERT(T, x) y = NULL x = T.root # 从根节点开始 while x != NULL y = x # 保存上一节点 if z.key &lt; x.key # 往左 x = x.left else # 往右 x = x.right z.p = y # 父节点 if y == NULL # tree T 为空 T.root = z else if z.key &lt; y.key y.left = z else y.right = z 程序的运行复杂度取决于二叉树的形状 插入的运行时间取决于二叉搜索树的高度h,程序的运行时间O(h) ,所以二叉树形状的好坏直接影响算法的运行时间. python代码实现为 123456789101112131415161718192021222324252627def _put(self, key, val, node): # If we hit the end of a branch, create a new node if node is None: return Node(key, val) # Follow left branch if key &lt; node.key: node.left = self._put(key, val, node.left) # Follow right branch elif key &gt; node.key: node.right = self._put(key, val, node.right) # Overwrite value else: node.val = val node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef put(self, key, val): \"\"\" Add a new key-value pair. Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" self.root = self._put(key, val, self.root) 删除删除总共分为三种情况: 如果删除节点x没有孩子,直接删除即可; 如果删除节点x有1个孩子,用孩子替换该节点位置; 如果删除节点x有2个孩子, 这个情况有些复杂.关键是要找到节点 x的继承者 . 节点z的继承者在节点z的右子树中有最小的关键值.这种情况下的操作分为下面步骤: 输入待删除的节点x 和 二叉搜索树T. 在节点x的右子树开始搜索:往右再往左找到最小值节点H; H右孩子为H的父节点, H的左孩子为X的左孩子; 示意图如下,应该一目了然: ](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![ 根据上面的描述,删除的伪代码可以分为两部分: 为了移动子树, 用一棵子树替换一棵子树,并成为双亲的孩子节点. 123456789TRANSPLANT(T, u, v)if u.p == NULLT.root = velse if u = u.p.leftu.p.left = velse u.p.right = vif v!= NULLv.p = u.p 根据第一步完成二叉搜索树的删除过程: 1234567891011121314TREE-DELETE(T, z)if z.left = NULLTRANSPLANT(T, z, z.right)else if (z.right == NULL)TRANSPLANT(T, z, z.left)elsey = TREE-MINIMUM(z.right)if y.p != zTRANSPLANT(T, y, y.right)y.right = z.righty.right.p = yTRANSPLANT(T, z, y)y.left = z.lefty.left.p = y 用python 实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def _delete(self, key, node): if node is None: return None if key &lt; node.key: node.left = self._delete(key, node.left) elif key &gt; node.key: node.right = self._delete(key, node.right) else: if node.right is None: return node.left elif node.left is None: return node.right else: old_node = node node = self._ceiling_node(key, node.right) node.right = self._delete_min(old_node.right) node.left = old_node.left node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _delete_min(self, node): if node.left is None: return node.right node.left = self._delete_min(node.left) node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _ceiling_node(self, key, node): \"\"\" Returns the node with the smallest key that is greater than or equal to the given value 'key' \"\"\" if node is None: return None if key &lt; node.key: # Ceiling is either in left subtree or is this node attempt_in_left = self._ceiling_node(key, node.left) if attempt_in_left is None: return node else: return attempt_in_left elif key &gt; node.key: # Ceiling must be in right subtree return self._ceiling_node(key, node.right) else: # Keys are equal so ceiling is node with this key return node 参考文献 &lt;&lt;算法导论第三版&gt;&gt; http://algs4.cs.princeton.edu/32bst/","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"code","slug":"python/code","permalink":"http://wangshub.github.io/categories/python/code/"},{"name":"algorithm","slug":"python/code/algorithm","permalink":"http://wangshub.github.io/categories/python/code/algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"}]},{"title":"python的webrtc库实现语音端点检测","slug":"python-vad","date":"2017-05-25T13:47:56.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/25/python-vad/","link":"","permalink":"http://wangshub.github.io/2017/05/25/python-vad/","excerpt":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ 引言语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段.现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: 语音转文字(ASR/STT) 语义内容(NLU/NLP) 文字转语音(TTS) 语音转文字(ASR/STT)在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: 麦克风降噪 声源定位 回声消除 唤醒词 语音端点检测 音频格式压缩","text":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ 引言语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段.现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: 语音转文字(ASR/STT) 语义内容(NLU/NLP) 文字转语音(TTS) 语音转文字(ASR/STT)在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: 麦克风降噪 声源定位 回声消除 唤醒词 语音端点检测 音频格式压缩 python 端点检测由于实际应用中,单纯依靠能量检测特征检测等方法很难判断人声说话的起始点,所以市面上大多数的语音产品都是使用唤醒词判断语音起始.另外加上声音回路,还可以做语音打断.这样的交互方式可能有些傻,每次必须喊一下 唤醒词 才能继续聊天.这种方式聊多了,个人感觉会嘴巴疼:-O .现在github上有snowboy唤醒词的开源库,大家可以登录snowboy官网训练自己的唤醒词模型. Kitt-AI : Snowboy Sensory : Sensory 考虑到用唤醒词嘴巴会累,所以大致调研了一下,python拥有丰富的库,直接import就能食用.这种方式容易受强噪声干扰,适合一个人在家玩玩. pyaudio: pip install pyaudio 可以从设备节点读取原始音频流数据,音频编码是PCM格式; webrtcvad: pip install webrtcvad 检测判断一组语音数据是否为空语音;当检测到持续时间长度 T1 vad检测都有语音活动,可以判定为语音起始;当检测到持续时间长度 T2 vad检测都没有有语音活动,可以判定为语音结束; 完整程序代码可以从我的github下载程序很简单,相信看一会儿就明白了 ''' Requirements: + pyaudio - `pip install pyaudio` + py-webrtcvad - `pip install webrtcvad` ''' import webrtcvad import collections import sys import signal import pyaudio from array import array from struct import pack import wave import time FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK_DURATION_MS = 30 # supports 10, 20 and 30 (ms) PADDING_DURATION_MS = 1500 # 1 sec jugement CHUNK_SIZE = int(RATE * CHUNK_DURATION_MS / 1000) # chunk to read CHUNK_BYTES = CHUNK_SIZE * 2 # 16bit = 2 bytes, PCM NUM_PADDING_CHUNKS = int(PADDING_DURATION_MS / CHUNK_DURATION_MS) # NUM_WINDOW_CHUNKS = int(240 / CHUNK_DURATION_MS) NUM_WINDOW_CHUNKS = int(400 / CHUNK_DURATION_MS) # 400 ms/ 30ms ge NUM_WINDOW_CHUNKS_END = NUM_WINDOW_CHUNKS * 2 START_OFFSET = int(NUM_WINDOW_CHUNKS * CHUNK_DURATION_MS * 0.5 * RATE) vad = webrtcvad.Vad(1) pa = pyaudio.PyAudio() stream = pa.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, start=False, # input_device_index=2, frames_per_buffer=CHUNK_SIZE) got_a_sentence = False leave = False def handle_int(sig, chunk): global leave, got_a_sentence leave = True got_a_sentence = True def record_to_file(path, data, sample_width): \"Records from the microphone and outputs the resulting data to 'path'\" # sample_width, data = record() data = pack('&lt;' + ('h' * len(data)), *data) wf = wave.open(path, 'wb') wf.setnchannels(1) wf.setsampwidth(sample_width) wf.setframerate(RATE) wf.writeframes(data) wf.close() def normalize(snd_data): \"Average the volume out\" MAXIMUM = 32767 # 16384 times = float(MAXIMUM) / max(abs(i) for i in snd_data) r = array('h') for i in snd_data: r.append(int(i * times)) return r signal.signal(signal.SIGINT, handle_int) while not leave: ring_buffer = collections.deque(maxlen=NUM_PADDING_CHUNKS) triggered = False voiced_frames = [] ring_buffer_flags = [0] * NUM_WINDOW_CHUNKS ring_buffer_index = 0 ring_buffer_flags_end = [0] * NUM_WINDOW_CHUNKS_END ring_buffer_index_end = 0 buffer_in = '' # WangS raw_data = array('h') index = 0 start_point = 0 StartTime = time.time() print(\"* recording: \") stream.start_stream() while not got_a_sentence and not leave: chunk = stream.read(CHUNK_SIZE) # add WangS raw_data.extend(array('h', chunk)) index += CHUNK_SIZE TimeUse = time.time() - StartTime active = vad.is_speech(chunk, RATE) sys.stdout.write('1' if active else '_') ring_buffer_flags[ring_buffer_index] = 1 if active else 0 ring_buffer_index += 1 ring_buffer_index %= NUM_WINDOW_CHUNKS ring_buffer_flags_end[ring_buffer_index_end] = 1 if active else 0 ring_buffer_index_end += 1 ring_buffer_index_end %= NUM_WINDOW_CHUNKS_END # start point detection if not triggered: ring_buffer.append(chunk) num_voiced = sum(ring_buffer_flags) if num_voiced &gt; 0.8 * NUM_WINDOW_CHUNKS: sys.stdout.write(' Open ') triggered = True start_point = index - CHUNK_SIZE * 20 # start point # voiced_frames.extend(ring_buffer) ring_buffer.clear() # end point detection else: # voiced_frames.append(chunk) ring_buffer.append(chunk) num_unvoiced = NUM_WINDOW_CHUNKS_END - sum(ring_buffer_flags_end) if num_unvoiced &gt; 0.90 * NUM_WINDOW_CHUNKS_END or TimeUse &gt; 10: sys.stdout.write(' Close ') triggered = False got_a_sentence = True sys.stdout.flush() sys.stdout.write('\\n') # data = b''.join(voiced_frames) stream.stop_stream() print(\"* done recording\") got_a_sentence = False # write to file raw_data.reverse() for index in range(start_point): raw_data.pop() raw_data.reverse() raw_data = normalize(raw_data) record_to_file(\"recording.wav\", raw_data, 2) leave = True stream.close() 程序运行方式sudo python vad.pyqrcode_for_gh_3586401957c4_258.jpg Remove","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"}]},{"title":"Atom editor","slug":"Atom-editor","date":"2017-05-25T13:27:42.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/25/Atom-editor/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Atom-editor/","excerpt":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","text":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","categories":[{"name":"Tool","slug":"Tool","permalink":"http://wangshub.github.io/categories/Tool/"},{"name":"Linux","slug":"Tool/Linux","permalink":"http://wangshub.github.io/categories/Tool/Linux/"}],"tags":[{"name":"Editor","slug":"Editor","permalink":"http://wangshub.github.io/tags/Editor/"}]},{"title":"Cmake 模板","slug":"Cmake-tutorial","date":"2017-05-24T16:03:34.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/05/25/Cmake-tutorial/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Cmake-tutorial/","excerpt":"","text":"由于之前的代码Cmake写的比较混乱，库链接的不规范，今天花了一些时间，重写Cmakelist.txt，方便后来的开发。可以根据我的模板开始进行C/C++的项目开发.主要分下面几个方面 更新CMakeList.txt文件 改变头文件位置，索引文件夹 上传新的gitlab CMakeList.txt模板全局CMakeList.txt文件123456789101112131415161718192021222324252627# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (aelos1s)# sys dirfind_package (Threads)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)add_subdirectory(lib)# 指定生成目标add_executable(aelos $&#123;DIR_SRCS&#125;)# 添加链接库# 生成链接库target_link_libraries(aelos aeloslib)# 多线程链接库target_link_libraries (aelos $&#123;CMAKE_THREAD_LIBS_INIT&#125;) 头文件库CMakeList.txt文件123456# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 aeloslib 链接库add_library (aeloslib $&#123;DIR_LIB_SRCS&#125;) 工程目录结构the file structure is |----main.cpp #主程序 |----lib/ #*.cpp and *.h |----build/ #可执行文件生成文件夹 工程参考模板的github地址 https://github.com/wangshub/cmake","categories":[{"name":"Programming","slug":"Programming","permalink":"http://wangshub.github.io/categories/Programming/"},{"name":"Linux","slug":"Programming/Linux","permalink":"http://wangshub.github.io/categories/Programming/Linux/"},{"name":"c/c++","slug":"Programming/Linux/c-c","permalink":"http://wangshub.github.io/categories/Programming/Linux/c-c/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Linux","slug":"Linux","permalink":"http://wangshub.github.io/tags/Linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-14T13:28:12.000Z","updated":"2018-03-17T09:10:40.000Z","comments":true,"path":"2017/04/14/hello-world/","link":"","permalink":"http://wangshub.github.io/2017/04/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}